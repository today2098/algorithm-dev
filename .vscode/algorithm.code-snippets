{
	// Place your algorithm-dev ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BIT2D": {
		"scope": "cpp",
		"prefix": "BIT2D",
		"body": [
			"// 二次元BIT．",
			"template <typename T>",
			"class BIT2D {",
			"public:",
			"    using value_type = T;",
			"",
			"private:",
			"    int m_h, m_w;",
			"    std::vector<std::vector<value_type>> m_tree;",
			"",
			"    static constexpr int lsb(int bit) { return bit & -bit; }",
			"    void build() {",
			"        for(int i = 1, h = height(); i <= h; ++i) {",
			"            int ni = i + lsb(i);",
			"            for(int j = 1, w = width(); j <= w; ++j) {",
			"                int nj = j + lsb(j);",
			"                if(ni <= h) m_tree[ni - 1][j - 1] += m_tree[i - 1][j - 1];",
			"                if(nj <= w) {",
			"                    m_tree[i - 1][nj - 1] += m_tree[i - 1][j - 1];",
			"                    if(ni <= h) m_tree[ni - 1][nj - 1] -= m_tree[i - 1][j - 1];",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(H*W).",
			"    BIT2D() : BIT2D(0, 0) {}",
			"    explicit BIT2D(int h, int w) : BIT2D(h, w, value_type()) {}",
			"    explicit BIT2D(int h, int w, const value_type &a) : m_h(h), m_w(w), m_tree(h, std::vector<value_type>(w, a)) {",
			"        assert(h >= 0 and w >= 0);",
			"        if(a != value_type()) build();",
			"    }",
			"",
			"    int height() const { return m_h; }",
			"    int width() const { return m_w; }",
			"    // (y,x)にある要素にaを加算する．O((logH)*logW).",
			"    void add(int y, int x, const value_type &a) {",
			"        assert(0 <= y and y < height());",
			"        assert(0 <= x and x < width());",
			"        for(int i = y + 1, h = height(); i <= h; i += lsb(i)) {",
			"            for(int j = x + 1, w = width(); j <= w; j += lsb(j)) m_tree[i - 1][j - 1] += a;",
			"        }",
			"    }",
			"    // [0,y)かつ[0,x)の範囲にある要素の総和を求める．O((logH)*logW).",
			"    value_type sum(int y, int x) const {",
			"        assert(0 <= y and y <= height());",
			"        assert(0 <= x and x <= width());",
			"        value_type res = 0;",
			"        for(int i = y; i >= 1; i -= lsb(i)) {",
			"            for(int j = x; j >= 1; j -= lsb(j)) res += m_tree[i - 1][j - 1];",
			"        }",
			"        return res;",
			"    }",
			"    // [y,yy)かつ[x,xx)の範囲にある要素の総和を求める．O((logH)*logW).",
			"    value_type sum(int y, int x, int yy, int xx) const {",
			"        assert(0 <= y and y <= yy and yy <= height());",
			"        assert(0 <= x and x <= xx and xx <= width());",
			"        return sum(yy, xx) - sum(yy, x) - sum(y, xx) + sum(y, x);",
			"    }",
			"    void reset() {",
			"        for(auto &v : m_tree) std::fill(v.begin(), v.end(), value_type());",
			"    }",
			"};"
		],
		"description": "二次元BIT"
	},
	"BellmanFord": {
		"scope": "cpp",
		"prefix": "BellmanFord",
		"body": [
			"template <typename T>",
			"class BellmanFord {",
			"    struct Edge {",
			"        int from, to;",
			"        T cost;",
			"        explicit Edge(int from_, int to_, T cost_) : from(from_), to(to_), cost(cost_) {}",
			"    };",
			"",
			"    int m_vn;                   // m_vn:=(ノード数).",
			"    std::vector<Edge> m_edges;  // m_edges[]:=(辺リスト).",
			"    std::vector<T> m_d;         // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;     // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"",
			"public:",
			"    BellmanFord() : BellmanFord(0) {}",
			"    explicit BellmanFord(size_t vn) : m_vn(vn), m_d(vn, infinity()), m_pre(vn, -1) {}",
			"    explicit BellmanFord(size_t vn, size_t en) : BellmanFord(vn) {",
			"        m_edges.reserve(en);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 辺数を返す．",
			"    int size() const { return m_edges.size(); }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_edges.emplace_back(from, to, cost);",
			"    }",
			"    // グラフ全体から負閉路を検出する．O(|V|*|E|).",
			"    bool find_negative_cycle() const {",
			"        std::vector<T> nd(order(), 0);",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(nd[to] > nd[from] + cost) {",
			"                    nd[to] = nd[from] + cost;",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) return false;  // 負閉路なし．",
			"        }",
			"        return true;  // 負閉路あり．",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|V|*|E|).",
			"    bool bellman_ford(int s) {",
			"        assert(0 <= s and s < order());",
			"        std::fill(m_d.begin(), m_d.end(), infinity());",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        m_d[s] = 0;",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(m_d[from] == infinity()) continue;",
			"                if(m_d[to] > m_d[from] + cost) {",
			"                    m_d[to] = m_d[from] + cost;",
			"                    m_pre[to] = from;",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) return false;  // 負閉路なし．",
			"        }",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(m_d[from] == infinity() or m_d[to] == -infinity()) continue;",
			"                if(m_d[from] == -infinity() or m_d[to] > m_d[from] + cost) {",
			"                    m_d[to] = -infinity();",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) break;",
			"        }",
			"        return true;  // 負閉路あり．",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < order());",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> shortest_path(int t) const {",
			"        assert(0 <= t and t < order());",
			"        std::vector<int> path;",
			"        if(distance(t) == infinity() or distance(t) == -infinity()) return path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "Bellman-Ford Algorithm（単一始点最短経路）"
	},
	"Combination": {
		"scope": "cpp",
		"prefix": "Combination",
		"body": [
			"template <int mod>",
			"class Combination {",
			"    static_assert(mod >= 2);",
			"",
			"    int m_sz;",
			"    std::vector<long long> m_fact;      // m_fact[n]:=(nの階乗).",
			"    std::vector<long long> m_inv;       // m_inv[n]:=(nの逆元).",
			"    std::vector<long long> m_inv_fact;  // m_inv_fact[n]:=(nの階乗の逆元).",
			"",
			"    void build(int n) {",
			"        if(n <= m_sz) return;",
			"        m_fact.resize(n);",
			"        m_inv.resize(n);",
			"        m_inv_fact.resize(n);",
			"        for(int i = m_sz; i < n; ++i) {",
			"            m_fact[i] = m_fact[i - 1] * i % mod;",
			"            m_inv[i] = mod - m_inv[mod % i] * (mod / i) % mod;",
			"            m_inv_fact[i] = m_inv_fact[i - 1] * m_inv[i] % mod;",
			"        }",
			"        m_sz = n;",
			"    }",
			"",
			"public:",
			"    Combination() : Combination(2) {}",
			"    explicit Combination(int n) : m_sz(2), m_fact(n), m_inv(n), m_inv_fact(n) {",
			"        assert(n >= 2);",
			"        m_fact[0] = m_fact[1] = 1;",
			"        m_inv[1] = 1;",
			"        m_inv_fact[0] = m_inv_fact[1] = 1;",
			"        build(n);",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // 階乗．O(1).",
			"    long long factorial(int n) {",
			"        assert(n >= 0);",
			"        build(n + 1);",
			"        return m_fact[n];",
			"    }",
			"    // 逆元．O(1).",
			"    long long inverse(int n) {",
			"        assert(n >= 1);",
			"        build(n + 1);",
			"        return m_inv[n];",
			"    }",
			"    // 階乗の逆元．O(1).",
			"    long long inverse_factorial(int n) {",
			"        assert(n >= 0);",
			"        build(n + 1);",
			"        return m_inv_fact[n];",
			"    }",
			"    // 順列．O(1).",
			"    long long nPk(int n, int k) {",
			"        assert(n >= 0);",
			"        assert(k >= 0);",
			"        if(n < k) return 0;",
			"        build(n + 1);",
			"        return m_fact[n] * m_inv_fact[n - k] % mod;",
			"    }",
			"    // 組合せ．O(1).",
			"    long long nCk(int n, int k) {",
			"        assert(n >= 0);",
			"        assert(k >= 0);",
			"        if(n < k) return 0;",
			"        build(n + 1);",
			"        return m_fact[n] * m_inv_fact[n - k] % mod * m_inv_fact[k] % mod;",
			"    }",
			"    // 重複組合せ．O(1).",
			"    long long nHk(int n, int k) {",
			"        assert(n >= 0);",
			"        assert(k >= 0);",
			"        if(k == 0) return 1;",
			"        if(n == 0) return 0;",
			"        return nCk(k + n - 1, k);",
			"    }",
			"};",
			"",
			"using Combination998244353 = Combination<998'244'353>;",
			"using Combination1000000007 = Combination<1'000'000'007>;"
		],
		"description": "数え上げ（mod付き）"
	},
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "Dijkstra",
		"body": [
			"template <typename T>",
			"class Dijkstra {",
			"    int m_vn;                                           // m_vn:=(ノード数).",
			"    std::vector<std::vector<std::pair<int, T> > > m_g;  // m_g[v][]:=(ノードvの隣接リスト). pair of (to, cost).",
			"    std::vector<T> m_d;                                 // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;                             // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"",
			"public:",
			"    Dijkstra() : Dijkstra(0) {}",
			"    explicit Dijkstra(size_t vn) : m_vn(vn), m_g(vn), m_d(vn, infinity()), m_pre(vn, -1) {}",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_g[from].emplace_back(to, cost);",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|E|*log|V|).",
			"    void dijkstra(int s) {",
			"        assert(0 <= s and s < order());",
			"        std::fill(m_d.begin(), m_d.end(), infinity());",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, std::greater<std::pair<T, int> > > pque;",
			"        m_d[s] = 0;",
			"        pque.emplace(m_d[s], s);",
			"        while(!pque.empty()) {",
			"            const auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(m_d[v] < dist) continue;",
			"            for(const auto &[to, cost] : m_g[v]) {",
			"                if(m_d[to] > m_d[v] + cost) {",
			"                    m_d[to] = m_d[v] + cost;",
			"                    m_pre[to] = v;",
			"                    pque.emplace(m_d[to], to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < order());",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> shortest_path(int t) const {",
			"        assert(0 <= t and t < order());",
			"        std::vector<int> path;",
			"        if(distance(t) == infinity()) return path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "Dijkstra's Algorithm（単一始点最短経路）"
	},
	"Dinic": {
		"scope": "cpp",
		"prefix": "Dinic",
		"body": [
			"template <typename T>  // T:容量の型.",
			"class Dinic {",
			"    struct Edge {",
			"        int to;   // to:=(行き先ノード).",
			"        T cap;    // cap:=(容量).",
			"        int rev;  // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[i]:=(i番目の辺情報). pair of (from, index).",
			"",
			"    T dfs(int v, int t, T flow, const std::vector<int> &d, std::vector<int> &iter) {",
			"        if(v == t) return flow;",
			"        for(int &i = iter[v], n = m_g[v].size(); i < n; ++i) {",
			"            Edge &e = m_g[v][i];",
			"            if(e.cap > 0 and d[e.to] > d[v]) {",
			"                T &&res = dfs(e.to, t, std::min(flow, e.cap), d, iter);",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    m_g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    Dinic() : Dinic(0) {}",
			"    explicit Dinic(size_t vn) : m_g(vn) {}",
			"    explicit Dinic(size_t vn, size_t en) : Dinic(vn) {",
			"        m_pos.reserve(en);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す.",
			"    int size() const { return m_pos.size(); }",
			"    // 容量capの有向辺を追加する．",
			"    int add_edge(int from, int to, T cap) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, idx_to);",
			"        m_g[to].emplace_back(from, 0, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ノードsからtへの最大流を求める．O((|V|^2)*|E|).",
			"    T max_flow(int s, int t) { return max_flow(s, t, infinity()); }",
			"    T max_flow(int s, int t, T flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        T res = 0;",
			"        std::vector<int> d(order());     // d[v]:=(ノードs-v間の増加パスの長さ).",
			"        std::vector<int> iter(order());  // iter[v]:=(m_g[v][]の次に調べるべきイテレータ).",
			"        while(res < flow) {",
			"            // (1) BFS: ノードsと各ノード間の増加パスの長さを求める．",
			"            std::fill(d.begin(), d.end(), -1);",
			"            d[s] = 0;",
			"            std::queue<int> que;",
			"            que.push(s);",
			"            while(!que.empty()) {",
			"                int v = que.front();",
			"                que.pop();",
			"                for(const Edge &e : m_g[v]) {",
			"                    if(e.cap > 0 and d[e.to] == -1) {",
			"                        d[e.to] = d[v] + 1;",
			"                        que.push(e.to);",
			"                    }",
			"                }",
			"            }",
			"            if(d[t] == -1) break;",
			"            // (2) DFS: 増加パスを探す．",
			"            std::fill(iter.begin(), iter.end(), 0);",
			"            while(res < flow) {",
			"                T &&tmp = dfs(s, t, flow - res, d, iter);",
			"                if(tmp == 0) break;",
			"                res += tmp;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    // i番目の辺情報を返す．",
			"    std::tuple<int, int, T, T> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, flow).",
			"    }",
			"    // 最小カットにより，グラフ上のノードを分割する．",
			"    std::vector<bool> min_cut(int s) const {",
			"        assert(0 <= s and s < order());",
			"        std::vector<bool> res(order(), false);",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            if(res[v]) continue;",
			"            res[v] = true;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(e.cap > 0 and !res[e.to]) que.push(e.to);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "Dinic's Algorithm（最大流問題）"
	},
	"DynamicModint": {
		"scope": "cpp",
		"prefix": "DynamicModint",
		"body": [
			"class ModintBase {};",
			"",
			"template <class T>",
			"using is_modint = std::is_base_of<ModintBase, T>;",
			"",
			"template <class T>",
			"inline constexpr bool is_modint_v = is_modint<T>::value;",
			"",
			"template <int id>",
			"class DynamicModint : ModintBase {",
			"    static int mod;",
			"    long long val;",
			"",
			"    void normalize() {",
			"        if(val < -mod or mod <= val) val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"public:",
			"    DynamicModint() : val(0) {}",
			"    DynamicModint(long long val) : val(val) {",
			"        normalize();",
			"    }",
			"",
			"    DynamicModint operator+() const { return DynamicModint(*this); }",
			"    DynamicModint operator-() const {",
			"        if(val == 0) DynamicModint();",
			"        DynamicModint res = *this;",
			"        res.val = mod - res.val;",
			"        return res;",
			"    }",
			"    DynamicModint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    DynamicModint operator++(int) {",
			"        DynamicModint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    DynamicModint operator--(int) {",
			"        DynamicModint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    DynamicModint &operator+=(const DynamicModint &rhs) {",
			"        val += rhs.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator-=(const DynamicModint &rhs) {",
			"        val -= rhs.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator*=(const DynamicModint &rhs) {",
			"        val = val * rhs.val % mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator/=(const DynamicModint &rhs) { return *this *= rhs.inv(); }",
			"",
			"    friend bool operator==(const DynamicModint &lhs, const DynamicModint &rhs) { return lhs.val == rhs.val; }",
			"    friend DynamicModint operator+(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) += rhs; }",
			"    friend DynamicModint operator-(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) -= rhs; }",
			"    friend DynamicModint operator*(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) *= rhs; }",
			"    friend DynamicModint operator/(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) /= rhs; }",
			"    friend std::istream &operator>>(std::istream &is, DynamicModint &rhs) {",
			"        is >> rhs.val;",
			"        rhs.normalize();",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const DynamicModint &rhs) { return os << rhs.val; }",
			"",
			"    static constexpr int get_id() { return id; }",
			"    static int modulus() { return mod; }",
			"    static void set_modulus(int mod) {",
			"        assert(mod >= 1);",
			"        DynamicModint::mod = mod;",
			"    }",
			"    long long value() const { return val; }",
			"    DynamicModint inv() const {",
			"        long long a = mod, b = val, u = 0, v = 1;",
			"        while(b != 0) {",
			"            long long t = a / b;",
			"            a -= b * t, u -= v * t;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return DynamicModint(u);",
			"    }",
			"    DynamicModint pow(long long k) const {",
			"        if(k < 0) return inv().pow(-k);",
			"        DynamicModint res = 1, mul = *this;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= mul;",
			"            mul *= mul;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend DynamicModint mod_inv(const DynamicModint &a) { return a.inv(); }",
			"    friend DynamicModint mod_pow(const DynamicModint &a, long long k) { return a.pow(k); }",
			"};",
			"",
			"template <int id>",
			"int DynamicModint<id>::mod = 1'000'000'007;"
		],
		"description": "動的Modint構造体"
	},
	"FordFulkerson": {
		"scope": "cpp",
		"prefix": "FordFulkerson",
		"body": [
			"template <typename T>  // T:容量の型.",
			"class FordFulkerson {",
			"    struct Edge {",
			"        int to;   // to:=(行き先ノード).",
			"        T cap;    // cap:=(容量).",
			"        int rev;  // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[]:=(i番目の辺情報). pair of (from, index).",
			"",
			"    T dfs(int v, int t, T flow, std::vector<bool> &seen) {",
			"        if(v == t) return flow;",
			"        seen[v] = true;",
			"        for(Edge &e : m_g[v]) {",
			"            if(e.cap > 0 and !seen[e.to]) {",
			"                T &&res = dfs(e.to, t, std::min(flow, e.cap), seen);",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    m_g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    FordFulkerson() : FordFulkerson(0) {}",
			"    explicit FordFulkerson(size_t vn) : m_g(vn) {}",
			"    explicit FordFulkerson(size_t vn, size_t en) : FordFulkerson(vn) {",
			"        m_pos.reserve(en);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す．",
			"    int size() const { return m_pos.size(); }",
			"    // 容量capの有向辺を追加する．",
			"    int add_edge(int from, int to, T cap) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, idx_to);",
			"        m_g[to].emplace_back(from, 0, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ノードsからtへの最大流を求める．O(F*|E|).",
			"    T max_flow(int s, int t) { return max_flow(s, t, infinity()); }",
			"    T max_flow(int s, int t, T flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        T res = 0;",
			"        std::vector<bool> seen(order());  // seen[v]:=(DFSにおいてノードvを調べたか).",
			"        while(res < flow) {",
			"            std::fill(seen.begin(), seen.end(), false);",
			"            T &&tmp = dfs(s, t, flow - res, seen);  // 増加パスを探す．",
			"            if(tmp == 0) break;",
			"            res += tmp;",
			"        }",
			"        return res;",
			"    }",
			"    // i番目の辺情報を返す．",
			"    std::tuple<int, int, T, T> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, flow).",
			"    }",
			"    // 最小カットにより，グラフ上のノードを分割する．",
			"    std::vector<bool> min_cut(int s) const {",
			"        assert(0 <= s and s < order());",
			"        std::vector<bool> res(order(), false);",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            if(res[v]) continue;",
			"            res[v] = true;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(e.cap > 0 and !res[e.to]) que.push(e.to);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "Ford-Fulkerson Algorithm（最大流問題）"
	},
	"HLD": {
		"scope": "cpp",
		"prefix": "HLD",
		"body": [
			"// Heavy-Light Decomposition（HL分解，重軽分解）.",
			"class HLD {",
			"    int m_vn;                           // m_vn:=(ノード数).",
			"    std::vector<std::vector<int>> m_g;  // m_g[v][]:=(ノードvの隣接リスト). グラフは森であること．",
			"    std::vector<int> m_par, m_head;     // m_par[v]:=(ノードvの親番号), m_head[v]:=(ノードvを含むheavy pathの端点).",
			"    std::vector<int> m_sub;             // m_sub[v]:=(ノードvを根とする部分木のサイズ).",
			"    std::vector<int> m_ord;             // m_ord[v]:=(ノードvの行きかけ順序).",
			"    bool m_is_built;",
			"",
			"    bool is_built() const { return m_is_built; }",
			"",
			"public:",
			"    // constructor. O(|V|).",
			"    HLD() : HLD(0) {}",
			"    explicit HLD(int vn) : m_vn(vn), m_g(vn), m_par(vn, -1), m_head(vn, -1), m_sub(vn, 1), m_ord(vn, -1), m_is_built(false) {",
			"        assert(vn >= 0);",
			"    }",
			"",
			"    // ノード数を取得する．",
			"    int order() const { return m_vn; }",
			"    // 無向辺を張る．",
			"    void add_edge(int u, int v) {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        m_g[u].push_back(v);",
			"        m_g[v].push_back(u);",
			"    }",
			"    // 木をHL分解する．O(|V|).",
			"    void build() {",
			"        auto dfs = [&](auto self, int u, int p) -> int {",
			"            assert(m_par[u] == -1);  // グラフに閉路はないこと．",
			"            m_par[u] = p, m_sub[u] = 1;",
			"            if(m_g[u].size() > 1 and m_g[u][0] == p) std::swap(m_g[u][0], m_g[u].back());",
			"            for(auto &v : m_g[u]) {",
			"                if(v == p) continue;",
			"                m_sub[u] += self(self, v, u);",
			"                if(m_sub[v] > m_sub[m_g[u][0]]) std::swap(m_g[u][0], v);  // m_g[u][0]にheavy childを格納する．",
			"            }",
			"            return m_sub[u];",
			"        };",
			"        int next = 0;",
			"        auto dfs2 = [&](auto self, int u, int p) -> void {",
			"            m_ord[u] = next++;",
			"            for(auto v : m_g[u]) {",
			"                if(v == p) continue;",
			"                m_head[v] = (v == m_g[u][0] ? m_head[u] : v);",
			"                self(self, v, u);",
			"            }",
			"        };",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"        for(int v = 0, end = order(); v < end; ++v) {",
			"            if(m_par[v] != -1) continue;",
			"            dfs(dfs, v, -1);",
			"            m_head[v] = v;",
			"            dfs2(dfs2, v, -1);",
			"        }",
			"        m_is_built = true;",
			"    }",
			"    // ノードvの行きがけ順序における番号を取得する．",
			"    int vertex_index(int v) const {",
			"        assert(0 <= v and v < order());",
			"        return m_ord[v];",
			"    }",
			"    const auto &vertex_index() const { return m_ord; }",
			"    // パスu-vにおける頂点属性のクエリに対応する範囲を求める．O(log|V|).",
			"    std::vector<std::pair<int, int>> vertex_query_ranges(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        assert(is_built());",
			"        std::vector<std::pair<int, int>> res;",
			"        do {",
			"            if(m_ord[u] > m_ord[v]) std::swap(u, v);",
			"            if(m_head[u] == m_head[v]) {",
			"                res.emplace_back(m_ord[u], m_ord[v] + 1);",
			"                return res;",
			"            }",
			"            res.emplace_back(m_ord[m_head[v]], m_ord[v] + 1);",
			"            v = m_par[m_head[v]];",
			"        } while(v != -1);",
			"        return {};  // 非連結の場合．",
			"    }",
			"    // ノードvを根とする部分木における頂点属性のクエリに対応する範囲を求める．O(1).",
			"    std::pair<int, int> vertex_query_range_of_subtree(int v) const {",
			"        assert(0 <= v and v < order());",
			"        assert(is_built());",
			"        return {m_ord[v], m_ord[v] + m_sub[v]};",
			"    }",
			"    // 木上のノードuとvの最近共通祖先を求める．O(log|V|).",
			"    int lca(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        assert(is_built());",
			"        do {",
			"            if(m_ord[u] > m_ord[v]) std::swap(u, v);",
			"            if(m_head[u] == m_head[v]) return u;",
			"            v = m_par[m_head[v]];",
			"        } while(v != -1);",
			"        return -1;  // 非連結の場合．",
			"    }",
			"};"
		],
		"description": "Heavy-Light Decomposition（HL分解，重軽分解）"
	},
	"Imos2D": {
		"scope": "cpp",
		"prefix": "Imos2D",
		"body": [
			"// 二次元いもす法．",
			"template <typename T>",
			"class Imos2D {",
			"    int m_h, m_w;",
			"    std::vector<std::vector<T> > m_dat;  // 0-based index.",
			"",
			"public:",
			"    Imos2D() : Imos2D(0, 0) {}",
			"    explicit Imos2D(size_t h, size_t w) : m_h(h), m_w(w), m_dat(h + 1, std::vector<T>(w + 1, 0)) {}",
			"",
			"    int height() const { return m_h; }",
			"    int width() const { return m_w; }",
			"    void add(int ly, int lx, int ry, int rx, T a) {",
			"        assert(0 <= ly and ly <= ry and ry <= height());",
			"        assert(0 <= lx and lx <= rx and rx <= width());",
			"        m_dat[ly][lx] += a;",
			"        m_dat[ly][rx] -= a;",
			"        m_dat[ry][lx] -= a;",
			"        m_dat[ry][rx] += a;",
			"    }",
			"    void build() {",
			"        for(int i = 0; i < height(); ++i) {",
			"            for(int j = 0; j < width(); ++j) m_dat[i][j + 1] += m_dat[i][j];",
			"        }",
			"        for(int i = 0; i < height(); ++i) {",
			"            for(int j = 0; j < width(); ++j) m_dat[i + 1][j] += m_dat[i][j];",
			"        }",
			"    }",
			"    T get(int y, int x) const {",
			"        assert(0 <= y and y < height());",
			"        assert(0 <= x and x < width());",
			"        return m_dat[y][x];",
			"    }",
			"    void reset() {",
			"        for(std::vector<T> &v : m_dat) std::fill(v.begin(), v.end(), 0);",
			"    }",
			"};"
		],
		"description": "二次元いもす法"
	},
	"IntervalSet": {
		"scope": "cpp",
		"prefix": "IntervalSet",
		"body": [
			"template <typename T, typename std::enable_if_t<std::is_arithmetic<T>::value, bool> = false>",
			"class Interval {",
			"    T l, u;",
			"",
			"public:",
			"    using value_type = T;",
			"",
			"    Interval() : Interval(0, 0) {}",
			"    explicit constexpr Interval(T l, T u) : l(l), u(u) {",
			"        assert(l <= u);",
			"    }",
			"",
			"    constexpr Interval operator+=(T rhs) {",
			"        l += rhs, u += rhs;",
			"        return *this;",
			"    }",
			"    constexpr Interval operator-=(T rhs) {",
			"        l -= rhs, u -= rhs;",
			"        return *this;",
			"    }",
			"    constexpr Interval operator*=(T rhs) {",
			"        l *= rhs, u *= rhs;",
			"        return *this;",
			"    }",
			"    constexpr Interval operator+=(const Interval &rhs) {",
			"        l += rhs.lower(), u += rhs.upper();",
			"        return *this;",
			"    }",
			"    constexpr Interval operator-=(const Interval &rhs) {",
			"        l -= rhs.lower(), u -= rhs.upper();",
			"        return *this;",
			"    }",
			"    constexpr Interval operator*=(const Interval &rhs) { return *this = *this * rhs; }",
			"",
			"    friend constexpr auto operator<=>(const Interval &lhs, const Interval &rhs) = default;",
			"    friend constexpr Interval operator+(const Interval &lhs, T rhs) { return Interval(lhs) += rhs; }",
			"    friend constexpr Interval operator-(const Interval &lhs, T rhs) { return Interval(lhs) -= rhs; }",
			"    friend constexpr Interval operator*(const Interval &lhs, T rhs) { return Interval(lhs) *= rhs; }",
			"    friend constexpr Interval operator+(const Interval &lhs, const Interval &rhs) { return Interval(lhs) += rhs; }",
			"    friend constexpr Interval operator-(const Interval &lhs, const Interval &rhs) { return Interval(lhs) -= rhs; }",
			"    friend constexpr Interval operator*(const Interval &lhs, const Interval &rhs) {",
			"        return Interval(std::min({lhs.lower() * rhs.lower(), lhs.lower() * rhs.upper(), lhs.upper() * rhs.lower(), lhs.upper() * rhs.upper()}),",
			"                        std::max({lhs.lower() * rhs.lower(), lhs.lower() * rhs.upper(), lhs.upper() * rhs.lower(), lhs.upper() * rhs.upper()}));",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Interval &a) { return os << \"[\" << a.lower() << \", \" << a.upper() << \")\"; }",
			"",
			"    constexpr T lower() const { return l; }",
			"    constexpr T upper() const { return u; }",
			"    constexpr T width() const { return upper() - lower(); }",
			"    constexpr bool contains(T x) const { return lower() <= x and x < upper(); }",
			"    constexpr int contains(const Interval &a) const { return contains(a.lower(), a.upper()); }",
			"    constexpr int contains(T l, T u) const {",
			"        if(l <= lower() and upper() <= u) return 2;  // 区間全体を含む場合．",
			"        if(upper() < l or u < lower()) return 0;     // 含まない場合．",
			"        return 1;                                    // 区間の一部のみ含む場合．",
			"    }",
			"",
			"    friend constexpr Interval overlap(const Interval &a, const Interval &b) {",
			"        T l = std::max(a.lower(), b.lower());",
			"        T u = std::min(a.upper(), b.upper());",
			"        return (l <= u ? Interval(l, u) : Interval(u, u));",
			"    }",
			"};",
			"",
			"template <typename Type>",
			"constexpr Interval<Type> overlap(std::initializer_list<Interval<Type> > list) {",
			"    Interval<Type> res(std::numeric_limits<Type>::min(), std::numeric_limits<Type>::max());",
			"    for(const auto &elem : list) res = overlap(res, elem);",
			"    return res;",
			"}",
			"",
			"// Interval Set（連続していない区間を管理するクラス）",
			"template <typename T, typename std::enable_if_t<std::is_arithmetic<T>::value, bool> = false>",
			"class IntervalSet {",
			"public:",
			"    using interval = Interval<T>;",
			"",
			"private:",
			"    std::set<interval> m_st;  // m_st:=(区間の集合).",
			"",
			"public:",
			"    using iterator = std::set<interval>::iterator;",
			"    using const_iterator = std::set<interval>::const_iterator;",
			"    using reverse_iterator = std::set<interval>::reverse_iterator;",
			"    using const_reverse_iterator = std::set<interval>::const_reverse_iterator;",
			"",
			"    IntervalSet() {",
			"        static_assert(min_limit() < max_limit());",
			"        // 番兵を配置．",
			"        m_st.emplace(std::numeric_limits<T>::lowest(), std::numeric_limits<T>::lowest());",
			"        m_st.emplace(std::numeric_limits<T>::max(), std::numeric_limits<T>::max());",
			"    }",
			"",
			"    static constexpr T min_limit() { return std::numeric_limits<T>::lowest() + 1; }",
			"    static constexpr T max_limit() { return std::numeric_limits<T>::max() - 1; }",
			"    // 区間追加．O(logN).",
			"    iterator insert(const interval &interval) { return insert(interval.lower(), interval.upper()); }",
			"    iterator insert(T l, T r) {",
			"        assert(min_limit() <= l and l < r and r <= max_limit());",
			"        auto left = lower_bound(l);",
			"        auto right = upper_bound(r);",
			"        if(std::prev(left)->upper() == l) {",
			"            left--;",
			"            l = left->lower();",
			"        } else if(left->lower() <= l) {",
			"            if(r <= left->upper()) return left;",
			"            l = left->lower();",
			"        }",
			"        if(r <= std::prev(right)->upper()) r = std::prev(right)->upper();",
			"        return m_st.emplace_hint(m_st.erase(left, right), l, r);",
			"    }",
			"    // 区間削除．O(logN).",
			"    iterator erase(const interval &interval) { return erase(interval.lower(), interval.upper()); }",
			"    iterator erase(T l, T r) {",
			"        assert(min_limit() <= l and l < r and r <= max_limit());",
			"        auto left = lower_bound(l);",
			"        auto right = upper_bound(r);",
			"        T ll = left->lower(), rr = std::prev(right)->upper();",
			"        auto iter = m_st.erase(left, right);",
			"        if(r < rr) iter = m_st.emplace_hint(iter, r, rr);",
			"        if(ll < l) m_st.emplace_hint(iter, ll, l);",
			"        return iter;",
			"    }",
			"    // 集合に含まれているか判定する．O(logN).",
			"    bool contains(T x) const {",
			"        assert(min_limit() <= x and x < max_limit());",
			"        auto iter = std::prev(upper_bound(x));",
			"        return iter->lower() <= x and x < iter->upper();",
			"    }",
			"    // 集合に含まれているか判定する．O(logN).",
			"    int contains(const interval &interval) const { return contains(interval.lower(), interval.upper()); }",
			"    int contains(T l, T r) const {",
			"        assert(min_limit() <= l and l < r and r <= max_limit());",
			"        auto left = lower_bound(l);",
			"        auto right = upper_bound(r);",
			"        if(left == right) return 0;                                                           // 含まない場合．",
			"        if(left == std::prev(right) and left->lower() <= l and r <= left->upper()) return 2;  // 区間全体を含む場合．",
			"        return 1;                                                                             // 区間の一部のみ含む場合．",
			"    }",
			"    // x以上で集合に含まれない最小の値 (mex: Minimum EXcluded value) を求める．O(logN).",
			"    T mex(T x) const {",
			"        auto iter = lower_bound(x);",
			"        return (x < iter->upper() ? iter->upper() : x);",
			"    }",
			"    void clear() { m_st.erase(begin(), end()); }",
			"",
			"    const_iterator begin() const { return std::next(m_st.begin()); }",
			"    const_iterator cbegin() const { return std::next(m_st.cbegin()); }",
			"    const_iterator end() const { return std::prev(m_st.end()); }",
			"    const_iterator cend() const { return std::prev(m_st.cend()); }",
			"    const_reverse_iterator rbegin() const { return std::next(m_st.rbegin()); }",
			"    const_reverse_iterator crbegin() const { return std::next(m_st.crbegin()); }",
			"    const_reverse_iterator rend() const { return std::prev(m_st.rend()); }",
			"    const_reverse_iterator crend() const { return std::prev(m_st.crend()); }",
			"    const_iterator lower_bound(T x) const {",
			"        assert(min_limit() <= x and x < max_limit());",
			"        auto iter = m_st.lower_bound(interval(x + 1, x + 1));",
			"        auto pre = std::prev(iter);",
			"        return (x < pre->upper() ? pre : iter);",
			"    }",
			"    const_iterator upper_bound(T x) const {",
			"        assert(min_limit() <= x and x < max_limit());",
			"        return m_st.lower_bound(interval(x + 1, x + 1));",
			"    }",
			"    iterator erase(const_iterator iter) { return m_st.erase(iter); }",
			"    iterator erase(const_iterator l, const_iterator r) { return m_st.erase(l, r); }",
			"};"
		],
		"description": "Interval Set（連続していない区間を管理するクラス）"
	},
	"Kitamasa": {
		"scope": "cpp",
		"prefix": "Kitamasa",
		"body": [
			"// きたまさ法．",
			"template <typename T>",
			"class Kitamasa {",
			"public:",
			"    using value_type = T;",
			"    using size_type = std::size_t;",
			"",
			"private:",
			"    size_type m_k;       // m_k:=(階数).",
			"    std::vector<T> m_a;  // m_a[]:=(初項数列).",
			"    std::vector<T> m_d;  // m_d[]:=(係数数列).",
			"",
			"    // f(n)->f(n+1). O(K).",
			"    std::vector<T> add(const std::vector<T> &x) const {",
			"        std::vector<T> y(m_k);",
			"        y[0] = x[m_k - 1] * m_d[0];",
			"        for(size_type i = 1; i < m_k; ++i) y[i] = x[i - 1] + x[m_k - 1] * m_d[i];",
			"        return y;",
			"    }",
			"    // f(n)->f(2*n). O(K^2).",
			"    std::vector<T> mul(const std::vector<T> &x) const {",
			"        std::vector<T> y(m_k, 0);",
			"        std::vector<T> t = x;",
			"        for(size_type i = 0; i < m_k; ++i) {",
			"            for(size_type j = 0; j < m_k; ++j) y[j] += x[i] * t[j];",
			"            if(i == m_k - 1) break;",
			"            t = add(t);",
			"        }",
			"        return y;",
			"    }",
			"    // f(n)を返す．O((K^2)*logN).",
			"    std::vector<T> f(size_type n) const {",
			"        if(n == 0) {",
			"            std::vector<T> x(m_k, 0);",
			"            x[0] = 1;",
			"            return x;  // f(0).",
			"        }",
			"        std::vector<T> &&x = mul(f(n >> 1));",
			"        if(n & 1ULL) x = add(x);",
			"        return x;",
			"    }",
			"",
			"public:",
			"    Kitamasa() : Kitamasa({0, 1}, {1, 1}) {}  // フィボナッチ数列．",
			"    explicit Kitamasa(std::vector<T> a, std::vector<T> d) : m_k(a.size()), m_a(std::move(a)), m_d(std::move(d)) {",
			"        assert(m_a.size() >= 1);",
			"        assert(m_a.size() == m_d.size());",
			"    }",
			"    template <std::input_iterator Iter>",
			"    explicit Kitamasa(Iter a_first, Iter a_last, Iter d_first, Iter d_last) : m_a(a_first, a_last), m_d(d_first, d_last) {",
			"        assert(m_a.size() >= 1);",
			"        assert(m_a.size() == m_d.size());",
			"        m_k = m_a.size();",
			"    }",
			"",
			"    T operator[](size_type n) const { return calc(n); }",
			"",
			"    // a[n]を求める．O((K^2)*logN).",
			"    T calc(size_type n) const {",
			"        const std::vector<T> &&x = f(n);",
			"        T res = 0;",
			"        for(size_type i = 0; i < m_k; ++i) res += m_a[i] * x[i];",
			"        return res;",
			"    }",
			"    // a[l:r]を求める．O((K^2)*logN+K*(r-l)).",
			"    std::vector<T> calc(size_type l, size_type r) const {",
			"        assert(l < r);",
			"        std::vector<T> res(r - l);",
			"        std::vector<T> &&x = f(l);",
			"        for(size_type i = l; i < r; ++i) {",
			"            for(size_type j = 0; j < m_k; ++j) res[i - l] += m_a[j] * x[j];",
			"            if(i == r - 1) break;",
			"            x = add(x);",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "きたまさ法"
	},
	"LCA": {
		"scope": "cpp",
		"prefix": "LCA",
		"body": [
			"// Lowest Common Ancestor（最近共通祖先）.",
			"template <typename T = int>  // T:Type of cost.",
			"class LCA {",
			"    int m_vn;                                           // m_vn:=(ノード数).",
			"    int m_lb;                                           // m_lb:=ceiling(log2(vn)).",
			"    std::vector<std::vector<std::pair<int, T> > > m_g;  // m_g[v][]:=(ノードvの隣接リスト). pair of (to, cost). グラフは木であること．",
			"    std::vector<std::vector<int> > m_par;               // m_par[k][v]:=(ノードvから2^k回遡って到達する親ノード). 親ノードがいない場合は-1．",
			"    std::vector<int> m_depth;                           // m_depth[v]:=(ノードvの深さ).",
			"    std::vector<T> m_dist;                              // m_dist[v]:=(根からノードvまでの距離).",
			"    std::vector<std::vector<T> > m_mx_cost;             // m_mx_cost[k][v]:=(ノードvから2^k回遡上するパスの中での最大コスト).",
			"    std::vector<int> m_ord;                             // m_ord[v]:=(DFS木におけるノードvの行きかけ順序).",
			"",
			"    void dfs(int u, int p, int depth, T distance, int &now) {",
			"        assert(m_ord[u] == -1);  // グラフ上に閉路はないこと．",
			"        m_ord[u] = now++;",
			"        m_depth[u] = depth, m_dist[u] = distance;",
			"        for(const auto &[v, cost] : m_g[u]) {",
			"            if(v == p) continue;",
			"            m_par[0][v] = u, m_mx_cost[0][v] = cost;",
			"            dfs(v, u, depth + 1, distance + cost, now);",
			"        }",
			"    }",
			"    // ノードvからk回遡上するパスの中での最大コストを求める．O(log|V|).",
			"    T max_cost_internal(int v, int k) const {",
			"        T res = -infinity();",
			"        for(int i = 0; i < m_lb; ++i) {",
			"            if(k >> i & 1) {",
			"                res = std::max(res, m_mx_cost[i][v]);",
			"                v = m_par[i][v];",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"public:",
			"    // constructor. O(|V|*log|V|).",
			"    LCA() : LCA(0) {}",
			"    explicit LCA(size_t vn) : m_vn(vn), m_lb(1), m_g(vn), m_depth(vn, 0), m_dist(vn, 0), m_ord(vn) {",
			"        while(1 << m_lb < order()) m_lb++;",
			"        m_par.assign(m_lb, std::vector<int>(order(), -1));",
			"        m_mx_cost.assign(m_lb, std::vector<T>(order(), -infinity()));",
			"        std::iota(m_ord.begin(), m_ord.end(), 0);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 無向辺を張る．ノードuとvは非連結であること．",
			"    void add_edge(int u, int v, T cost = 0) {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        m_g[u].emplace_back(v, cost);",
			"        m_g[v].emplace_back(u, cost);",
			"    }",
			"    // 祖先木を構築する．O(|V|*log|V|).",
			"    void build(const std::vector<int> &rts = {}) {",
			"        assert(std::find_if(rts.cbegin(), rts.cend(), [&](int v) -> bool { return !(0 <= v and v < order()); }) == rts.cend());",
			"        std::fill(m_par[0].begin(), m_par[0].end(), -1);",
			"        std::fill(m_mx_cost[0].begin(), m_mx_cost[0].end(), -infinity());",
			"        std::fill(m_ord.begin(), m_ord.end(), -1);",
			"        int now = 0;",
			"        for(int rt : rts) {",
			"            if(m_ord[rt] == -1) dfs(rt, -1, 0, 0, now);",
			"        }",
			"        for(int v = 0; v < order(); ++v) {",
			"            if(m_ord[v] == -1) dfs(v, -1, 0, 0, now);",
			"        }",
			"        for(int k = 0; k < m_lb - 1; ++k) {",
			"            for(int v = 0; v < order(); ++v) {",
			"                if(m_par[k][v] == -1) {",
			"                    m_par[k + 1][v] = -1;",
			"                    m_mx_cost[k + 1][v] = -infinity();",
			"                } else {",
			"                    m_par[k + 1][v] = m_par[k][m_par[k][v]];",
			"                    m_mx_cost[k + 1][v] = std::max(m_mx_cost[k][v], m_mx_cost[k][m_par[k][v]]);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // ノードvの祖先をk代遡る．O(log|V|).",
			"    int trace_back(int v, int k) const {",
			"        assert(0 <= v and v < order());",
			"        assert(0 <= k and k < order());",
			"        if(k > m_depth[v]) return -1;",
			"        for(int i = 0; i < m_lb; ++i) {",
			"            if(k >> i & 1) v = m_par[i][v];",
			"        }",
			"        return v;",
			"    }",
			"    // 木上のノードuとvの最近共通祖先を求める．2つのノードが非連結の場合，-1を返す．O(log|V|).",
			"    int lca(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        if(m_depth[u] > m_depth[v]) std::swap(u, v);",
			"        v = trace_back(v, m_depth[v] - m_depth[u]);  // 同じ深さに合わせる．",
			"        if(u == v) return u;",
			"        for(int k = m_lb - 1; k >= 0; --k) {",
			"            if(m_par[k][u] != m_par[k][v]) u = m_par[k][u], v = m_par[k][v];  // 異なったら根に近づける．",
			"        }",
			"        return m_par[0][u];",
			"    }",
			"    // ノードvの深さを返す．O(1).",
			"    T depth(int v) const {",
			"        assert(0 <= v and v < order());",
			"        return m_depth[v];",
			"    }",
			"    // ノードu, v間の長さを求める．O(log|V|).",
			"    int length(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        int w = lca(u, v);",
			"        if(w == -1) return -1;",
			"        return m_depth[u] + m_depth[v] - 2 * m_depth[w];",
			"    }",
			"    // 根とノードv間の距離を返す．O(1).",
			"    T distance(int v) const {",
			"        assert(0 <= v and v < order());",
			"        return m_dist[v];",
			"    }",
			"    // ノードu, v間の距離を求める．O(log|V|).",
			"    T distance(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        int w = lca(u, v);",
			"        if(w == -1) return infinity();",
			"        return m_dist[u] + m_dist[v] - 2 * m_dist[w];",
			"    }",
			"    // ノードu, v間のパスにおける最大コストを求める．O(log|V|).",
			"    T max_cost(int u, int v) const {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        int w = lca(u, v);",
			"        if(w == -1) return -infinity();",
			"        T res = -infinity();",
			"        res = std::max(res, max_cost_internal(u, depth(u) - depth(w)));",
			"        res = std::max(res, max_cost_internal(v, depth(v) - depth(w)));",
			"        return res;",
			"    }",
			"    // 木の圧縮．",
			"    // 任意の頂点集合とそのLCAからなる，頂点同士の関係性を維持した木を作成する．O(K*log|V|).",
			"    std::map<int, std::vector<int> > auxiliary_tree(std::vector<int> &vs) const {",
			"        assert(std::find_if(vs.cbegin(), vs.cend(), [&](int v) -> bool { return !(0 <= v and v < order()); }) == vs.cend());",
			"        const int n = vs.size();",
			"        if(n == 0) return std::map<int, std::vector<int> >();",
			"        std::map<int, std::vector<int> > res;  // res[v][]:=(圧縮した木におけるノードvの隣接リスト).",
			"        auto comp = [&](int u, int v) -> bool { return m_ord[u] < m_ord[v]; };",
			"        std::sort(vs.begin(), vs.end(), comp);",
			"        vs.erase(std::unique(vs.begin(), vs.end()), vs.end());",
			"        std::stack<int> st;",
			"        st.push(vs[0]);",
			"        for(int i = 1; i < n; ++i) {",
			"            int w = lca(vs[i - 1], vs[i]);",
			"            if(w == -1) {",
			"                while(st.size() > 1) {",
			"                    int v = st.top();",
			"                    st.pop();",
			"                    res[st.top()].push_back(v);",
			"                    res[v].push_back(st.top());",
			"                }",
			"                res[st.top()];  // for unconnected node.",
			"                st.pop();",
			"            } else if(w != vs[i - 1]) {",
			"                int v = st.top();",
			"                st.pop();",
			"                while(!st.empty() and m_depth[st.top()] > m_depth[w]) {",
			"                    res[st.top()].push_back(v);",
			"                    res[v].push_back(st.top());",
			"                    v = st.top();",
			"                    st.pop();",
			"                }",
			"                if(st.empty() or st.top() != w) {",
			"                    st.push(w);",
			"                    vs.push_back(w);",
			"                }",
			"                res[w].push_back(v);",
			"                res[v].push_back(w);",
			"            }",
			"            st.push(vs[i]);",
			"        }",
			"        while(st.size() > 1) {",
			"            int v = st.top();",
			"            st.pop();",
			"            res[st.top()].push_back(v);",
			"            res[v].push_back(st.top());",
			"        }",
			"        res[st.top()];  // for unconnected node.",
			"        std::sort(vs.begin(), vs.end(), comp);",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Lowest Common Ancestor（最近共通祖先）"
	},
	"LinearSieve": {
		"scope": "cpp",
		"prefix": "LinearSieve",
		"body": [
			"// 線形篩．",
			"class LinearSieve {",
			"    int m_sz;",
			"    // m_lpf[i]:=(正の奇数2*i+1の最小素因数). Least prime factor. m_lpf[i]==2*i+1 のとき，2*i+1は素数．",
			"    std::vector<int> m_lpf;",
			"    std::vector<int> m_primes;  // m_primes[]:=(自然数n未満の素数リスト).",
			"",
			"public:",
			"    // constructor. n未満の自然数を篩にかける．O(N).",
			"    LinearSieve() : LinearSieve(0) {}",
			"    explicit LinearSieve(int n) : m_sz(n), m_lpf(n / 2, -1) {",
			"        assert(n >= 0);",
			"        if(size() <= 2) return;",
			"        m_primes.push_back(2);",
			"        int p = 3;",
			"        for(int i = 1, end = m_lpf.size(); i < end; ++i) {",
			"            if(m_lpf[i] == -1) {",
			"                m_lpf[i] = p;",
			"                m_primes.push_back(p);",
			"            }",
			"            for(const auto &prime : m_primes | std::ranges::views::drop(1)) {",
			"                if(prime > m_lpf[i] or (long long) p * prime >= m_sz) break;",
			"                m_lpf[p * prime / 2] = prime;",
			"            }",
			"            p += 2;",
			"        }",
			"        m_primes.shrink_to_fit();",
			"    }",
			"",
			"    int size() const { return m_sz; }",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n < size());",
			"        if(n == 2) return true;",
			"        if(n % 2 == 0) return false;",
			"        return m_lpf[n / 2] == n;",
			"    }",
			"    // 自然数nの最小素因数を取得する．O(1).",
			"    int lpf(int n) const {",
			"        assert(0 <= n and n < size());",
			"        if(n < 2) return -1;",
			"        if(n % 2 == 0) return 2;",
			"        return m_lpf[n / 2];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n < size());",
			"        std::map<int, int> res;",
			"        for(; n % 2 == 0; n /= 2) ++res[2];",
			"        for(; n > 1; n /= m_lpf[n / 2]) ++res[m_lpf[n / 2]];",
			"        return res;",
			"    }",
			"    // 素数リストを参照する．O(1).",
			"    const std::vector<int> &primes() const { return m_primes; }",
			"};"
		],
		"description": "線形篩"
	},
	"LowLink": {
		"scope": "cpp",
		"prefix": "LowLink",
		"body": [
			"class LowLink {",
			"    int m_vn;                                 // m_vn:=(頂点数).",
			"    std::vector<std::vector<int> > m_g;       // m_g[v][]:=(頂点vの隣接リスト).",
			"    std::vector<int> m_aps;                   // m_aps[]:=(関節点のリスト). Articulation points.",
			"    std::vector<std::pair<int, int> > m_brs;  // m_brs[]:=(橋のリスト). Bridges.",
			"",
			"    void dfs(int u, int p, std::vector<int> &ord, std::vector<int> &low, int &now) {",
			"        ord[u] = low[u] = now++;",
			"        int degree = 0;      // degree:=(DFS木での頂点uにおける葉方向への出次数).",
			"        bool is_ap = false;  // is_ap:=(頂点uが関節点か).",
			"        for(int v : m_g[u]) {",
			"            if(v == p) continue;",
			"            if(ord[v] == -1) {  // 頂点vが未訪問のとき．",
			"                degree++;",
			"                dfs(v, u, ord, low, now);",
			"                low[u] = std::min(low[u], low[v]);",
			"                if(ord[u] < low[v]) {  // 辺(u,v)が橋のとき．",
			"                    if(u < v) m_brs.emplace_back(u, v);",
			"                    else m_brs.emplace_back(v, u);",
			"                }",
			"                if(p != -1 and ord[u] <= low[v]) is_ap = true;  // 根以外で関節点のとき．",
			"            } else {                                            // 辺(u,v)が後退辺のとき．",
			"                low[u] = std::min(low[u], ord[v]);",
			"            }",
			"        }",
			"        if(p == -1 and degree > 1) is_ap = true;  // 根が関節点のとき．",
			"        if(is_ap) m_aps.push_back(u);",
			"    }",
			"",
			"public:",
			"    // constructor. O(|V|).",
			"    LowLink() : LowLink(0) {}",
			"    explicit LowLink(size_t vn) : m_vn(vn), m_g(vn) {}",
			"",
			"    // 頂点数を返す．",
			"    int order() const { return m_vn; }",
			"    // 無向辺を張る．",
			"    void add_edge(int u, int v) {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        m_g[u].push_back(v);",
			"        m_g[v].push_back(u);",
			"    }",
			"    // 無向グラフの橋と関節点を求める．O(|V|+|E|).",
			"    void lowlink() {",
			"        m_aps.clear();",
			"        m_brs.clear();",
			"        // ord[v]:=(DFS木における頂点vの行きかけ順序).",
			"        // low[v]:=(DFS木において，頂点vから葉方向への辺を0回以上，後退辺を高々1回用いて到達できる頂点wに対するord[w]の最小値).",
			"        std::vector<int> ord(order(), -1), low(order());",
			"        int now = 0;",
			"        for(int v = 0; v < order(); ++v) {",
			"            if(ord[v] == -1) dfs(v, -1, ord, low, now);",
			"        }",
			"        std::sort(m_aps.begin(), m_aps.end());",
			"        std::sort(m_brs.begin(), m_brs.end());",
			"    }",
			"    // 関節点のリストを参照する．",
			"    const std::vector<int> &articulation_points() const { return m_aps; }",
			"    // 橋のリストを参照する．",
			"    const std::vector<std::pair<int, int> > &bridges() const { return m_brs; }",
			"};"
		],
		"description": "Low-Link（橋，関節点）"
	},
	"Manacher": {
		"scope": "cpp",
		"prefix": "Manacher",
		"body": [
			"// Manacher's Algorithm（最長回文）.",
			"template <class Sequence>",
			"class Manacher {",
			"    int m_sz;  // m_sz:=(配列サイズ).",
			"    // m_radius[2*k]:=(k文字目を中心とする奇数長の最長回文の半径),",
			"    // m_radius[2*k+1]:=(k文字目とk+1文字目の間を中心とする偶数長の最長回文の半径).",
			"    std::vector<int> m_radius;",
			"",
			"public:",
			"    // constructor. 引数はSTLのシーケンスコンテナ．O(|S|).",
			"    Manacher() : Manacher(Sequence()) {}",
			"    explicit Manacher(const Sequence &s) : m_sz(s.size()), m_radius(2 * s.size(), 0) {",
			"        if(size() == 0) return;",
			"        const int n = 2 * size() - 1;",
			"        Sequence t(n, 0);",
			"        for(int i = 0; i < size(); ++i) t[2 * i] = s[i];",
			"        int i = 0, j = 0;",
			"        while(i < n) {",
			"            while(0 <= i - j and i + j < n and t[i - j] == t[i + j]) j++;",
			"            m_radius[i] = j;",
			"            int k = 1;",
			"            while(0 <= i - k and i + k < n and k + m_radius[i - k] < j) {",
			"                m_radius[i + k] = m_radius[i - k];",
			"                k++;",
			"            }",
			"            i += k, j -= k;",
			"        }",
			"    }",
			"",
			"    // 配列のサイズを返す．",
			"    int size() const { return m_sz; }",
			"    // k文字目を中心とする奇数長の最長回文の半径を返す．",
			"    int odd_radius(int k) const {",
			"        assert(0 <= k and k < size());",
			"        return (m_radius[2 * k] + 1) / 2;",
			"    }",
			"    // k文字目とk+1文字目の間を中心とする偶数長の最長回文の半径を返す．",
			"    int even_radius(int k) const {",
			"        assert(0 <= k and k < size() - 1);",
			"        return m_radius[2 * k + 1] / 2;",
			"    }",
			"    // 部分列s[l:r]が回文か判定する．",
			"    bool is_palindrome(int l, int r) const {",
			"        assert(0 <= l and l < r and r <= size());",
			"        int mid = (l + r) / 2;",
			"        if((r - l) & 1) return odd_radius(mid) >= (r - l + 1) / 2;",
			"        return even_radius(mid) >= (r - l) / 2;",
			"    }",
			"};"
		],
		"description": "Manacher's Algorithm（最長回文）"
	},
	"Mo": {
		"scope": "cpp",
		"prefix": "Mo",
		"body": [
			"// Mo's Algorithm（クエリ平方分割）.",
			"class Mo {",
			"    int m_len;                                          // m_len:=(区間の長さ).",
			"    int m_q;                                            // m_q:=(クエリ数).",
			"    std::vector<std::tuple<int, int, int> > m_queries;  // m_queries[i]:=(i番目の区間クエリ). tuple of (left, right, index).",
			"",
			"    void sort_queries() {",
			"        if(m_q == 0) return;",
			"        const int width = std::max(m_len / (int)std::sqrt(m_q), 1);  // width:=N/√Q.",
			"        std::sort(m_queries.begin(), m_queries.end(), [&width](const std::tuple<int, int, int> &a, const std::tuple<int, int, int> &b) -> bool {",
			"            const auto &[al, ar, _] = a;",
			"            const auto &[bl, br, __] = b;",
			"            int a_block = al / width, b_block = bl / width;",
			"            if(a_block == b_block) return (a_block & 1 ? ar > br : ar < br);",
			"            return a_block < b_block;",
			"        });",
			"    }",
			"",
			"public:",
			"    Mo() : Mo(0) {}",
			"    explicit Mo(size_t n) : m_len(n), m_q(0) {}",
			"    explicit Mo(size_t n, size_t q) : Mo(n) {",
			"        m_queries.reserve(q);",
			"    }",
			"",
			"    // 区間[l,r)についてのクエリを追加する．",
			"    void insert(int l, int r) {",
			"        assert(0 <= l and l < r and r <= m_len);",
			"        m_queries.emplace_back(l, r, m_q++);",
			"    }",
			"    // 各クエリを実行する．O(Q*logQ+α*N*√Q).",
			"    template <class F1, class F2, class F3>",
			"    void execute(const F1 &add, const F2 &del, const F3 &solve) { execute(add, del, add, del, solve); }",
			"    template <class F1, class F2, class F3, class F4, class F5>",
			"    void execute(const F1 &add_l, const F2 &del_l, const F3 &add_r, const F4 &del_r, const F5 &solve) {",
			"        sort_queries();",
			"        int l = 0, r = 0;",
			"        for(const auto &[nl, nr, idx] : m_queries) {",
			"            while(nl < l) add_l(--l);",
			"            while(r < nr) add_r(r++);",
			"            while(l < nl) del_l(l++);",
			"            while(nr < r) del_r(--r);",
			"            solve(idx);",
			"        }",
			"    }",
			"    void reset() {",
			"        m_queries.clear();",
			"        m_q = 0;",
			"    }",
			"};"
		],
		"description": "Mo's Algorithm（クエリ平方分割）"
	},
	"Modint": {
		"scope": "cpp",
		"prefix": "Modint",
		"body": [
			"class ModintBase {};",
			"",
			"template <class T>",
			"using is_modint = std::is_base_of<ModintBase, T>;",
			"",
			"template <class T>",
			"inline constexpr bool is_modint_v = is_modint<T>::value;",
			"",
			"template <int mod>",
			"class Modint : ModintBase {",
			"    static_assert(mod >= 1);",
			"",
			"    long long val;",
			"",
			"    constexpr void normalize() {",
			"        if(val < -mod or mod <= val) val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"public:",
			"    constexpr Modint() : val(0) {}",
			"    constexpr Modint(long long val) : val(val) {",
			"        normalize();",
			"    }",
			"",
			"    constexpr Modint operator+() const { return Modint(*this); }",
			"    constexpr Modint operator-() const {",
			"        if(val == 0) Modint();",
			"        Modint res = *this;",
			"        res.val = mod - res.val;",
			"        return res;",
			"    }",
			"    constexpr Modint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    constexpr Modint operator++(int) {",
			"        Modint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    constexpr Modint operator--(int) {",
			"        Modint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    constexpr Modint &operator+=(const Modint &rhs) {",
			"        val += rhs.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator-=(const Modint &rhs) {",
			"        val -= rhs.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator*=(const Modint &rhs) {",
			"        val = val * rhs.val % mod;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator/=(const Modint &rhs) { return *this *= rhs.inv(); }",
			"",
			"    friend constexpr bool operator==(const Modint &lhs, const Modint &rhs) { return lhs.val == rhs.val; }",
			"    friend constexpr Modint operator+(const Modint &lhs, const Modint &rhs) { return Modint(lhs) += rhs; }",
			"    friend constexpr Modint operator-(const Modint &lhs, const Modint &rhs) { return Modint(lhs) -= rhs; }",
			"    friend constexpr Modint operator*(const Modint &lhs, const Modint &rhs) { return Modint(lhs) *= rhs; }",
			"    friend constexpr Modint operator/(const Modint &lhs, const Modint &rhs) { return Modint(lhs) /= rhs; }",
			"    friend std::istream &operator>>(std::istream &is, Modint &rhs) {",
			"        is >> rhs.val;",
			"        rhs.normalize();",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Modint &rhs) { return os << rhs.val; }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    constexpr long long value() const { return val; }",
			"    constexpr Modint inv() const {",
			"        long long a = mod, b = val, u = 0, v = 1;",
			"        while(b != 0) {",
			"            long long t = a / b;",
			"            a -= b * t, u -= v * t;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return Modint(u);",
			"    }",
			"    constexpr Modint pow(long long k) const {",
			"        if(k < 0) return inv().pow(-k);",
			"        Modint res = 1, mul = *this;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= mul;",
			"            mul *= mul;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend constexpr Modint mod_inv(const Modint &a) { return a.inv(); }",
			"    friend constexpr Modint mod_pow(const Modint &a, long long k) { return a.pow(k); }",
			"};",
			"",
			"using mint998244353 = Modint<998'244'353>;",
			"using mint1000000007 = Modint<1'000'000'007>;"
		],
		"description": "Modint構造体"
	},
	"PartiallyPersistentUnionFind": {
		"scope": "cpp",
		"prefix": "PartiallyPersistentUnionFind",
		"body": [
			"// 部分永続Union-Find．",
			"class PartiallyPersistentUnionFind {",
			"    using pii = std::pair<int, int>;",
			"",
			"    int m_now;  // m_now:=(現在時刻).",
			"    int m_vn;   // m_vn:=(要素数).",
			"    int m_gn;   // m_gn:=(グループ数).",
			"    // m_par[x][]:=(要素xについて時刻tとその時刻における親parの情報リスト). pair of (t, par).",
			"    // 値idが0未満の場合，xは根であり，値parの絶対値は属するグループのサイズを表す．",
			"    std::vector<std::vector<pii> > m_par;",
			"",
			"    static constexpr int infinity() { return std::numeric_limits<int>::max(); }",
			"",
			"public:",
			"    PartiallyPersistentUnionFind() : PartiallyPersistentUnionFind(0) {}",
			"    explicit PartiallyPersistentUnionFind(size_t vn)",
			"        : m_now(0), m_vn(vn), m_gn(vn), m_par(vn, std::vector<pii>({{0, -1}})) {}",
			"",
			"    // 現在の時刻を返す．",
			"    int now() const { return m_now; }",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 現時刻において要素xが属するグループ（根付き木）の根を返す．O(logN).",
			"    int root(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        while(m_par[x].back().second >= 0) x = m_par[x].back().second;",
			"        return x;",
			"    }",
			"    // 時刻tにおいて要素xが属するグループ（根付き木）の根を返す．O(logN).",
			"    int root(int x, int t) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= t and t <= now());",
			"        auto itr = std::lower_bound(m_par[x].cbegin(), m_par[x].cend(), pii(t, -infinity()));",
			"        if(itr == m_par[x].cend() or itr->first > t) itr--;",
			"        if(itr->second < 0) return x;",
			"        return root(itr->second, t);",
			"    }",
			"    // 現時刻において要素xが属するグループのサイズを返す．O(logN).",
			"    int size(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)].back().second;",
			"    }",
			"    // 時刻tにおいて要素xが属するグループのサイズを返す．O(logN).",
			"    int size(int x, int t) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= t and t <= now());",
			"        auto itr = std::lower_bound(m_par[x].cbegin(), m_par[x].cend(), pii(t, -infinity()));",
			"        if(itr == m_par[x].cend() or itr->first > t) itr--;",
			"        if(itr->second < 0) return -itr->second;",
			"        return size(itr->second, t);",
			"    }",
			"    // 現在において要素x, yが同じグループに属するか判定する．O(logN).",
			"    bool is_same(int x, int y) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 時刻tにおいて要素x, yが同じグループに属するか判定する．O(logN).",
			"    bool is_same(int x, int y, int t) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        assert(0 <= t and t <= now());",
			"        return root(x, t) == root(y, t);",
			"    }",
			"    // 要素x, yが属するそれぞれのグループを併合し，時間を+1進める．O(logN).",
			"    bool unite(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        m_now++;",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;",
			"        int sz_x = -m_par[x].back().second;",
			"        int sz_y = -m_par[y].back().second;",
			"        if(sz_x < sz_y) std::swap(x, y);  // Merge technique (unite by size).",
			"        m_par[x].emplace_back(now(), -sz_x - sz_y);",
			"        m_par[y].emplace_back(now(), x);",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_now = 0;",
			"        m_gn = vn();",
			"        for(std::vector<pii> &history : m_par) history.resize(1);",
			"    }",
			"};"
		],
		"description": "部分永続Union-Find"
	},
	"PotentializedUnionFind": {
		"scope": "cpp",
		"prefix": "PotentializedUnionFind",
		"body": [
			"// 重み付きUnion-Find．",
			"template <typename T>",
			"class PotentializedUnionFind {",
			"    int m_vn;  // m_vn:=(要素数).",
			"    int m_gn;  // m_gn:=(グループ数).",
			"    // m_par[x]:=(要素xの親). 0未満の場合，xは根であり，値の絶対値は属するグループのサイズを表す．",
			"    std::vector<int> m_par;",
			"    std::vector<T> m_h;  // m_h[x]:=(要素xのポテンシャル).",
			"",
			"public:",
			"    PotentializedUnionFind() : PotentializedUnionFind(0) {}",
			"    explicit PotentializedUnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1), m_h(vn, 0) {}",
			"",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 要素xが属するグループ（根付き木）の根を返す．O(α(N)).",
			"    int root(int x) {",
			"        assert(0 <= x and x < vn());",
			"        if(m_par[x] < 0) return x;",
			"        int rt = root(m_par[x]);  // 経路圧縮．",
			"        m_h[x] += m_h[m_par[x]];",
			"        return m_par[x] = rt;",
			"    }",
			"    // 要素xが属するグループのサイズを返す．",
			"    int size(int x) {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)];",
			"    }",
			"    // 要素xのポテンシャルを返す．",
			"    T potential(int x) {",
			"        assert(0 <= x and x < vn());",
			"        root(x);",
			"        return m_h[x];",
			"    }",
			"    // 要素x, yが同じグループに属するか判定する．",
			"    bool is_same(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 要素xに対するyの相対ポテンシャルを返す．",
			"    T diff(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return potential(y) - potential(x);",
			"    }",
			"    // diff(x,y)==d となるように，要素x, yが属するそれぞれのグループを併合する．",
			"    bool unite(int x, int y, T d) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        d = potential(x) + d - potential(y);",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;     // Do nothing.",
			"        if(-m_par[x] < -m_par[y]) {  // Merge technique (union by size).",
			"            std::swap(x, y);",
			"            d = -d;",
			"        }",
			"        m_par[x] += m_par[y];",
			"        m_par[y] = x;",
			"        m_h[y] = d;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"        std::fill(m_h.begin(), m_h.end(), 0);",
			"    }",
			"};"
		],
		"description": "重み付きUnion-Find"
	},
	"Prim": {
		"scope": "cpp",
		"prefix": "Prim",
		"body": [
			"template <typename T>",
			"class Prim {",
			"    std::vector<std::vector<std::pair<int, T> > > m_g;  // m_g[v][]:=(ノードvの隣接リスト). pair of (to, cost).",
			"",
			"public:",
			"    Prim() : Prim(0) {}",
			"    explicit Prim(size_t vn) : m_g(vn) {}",
			"",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 重み付き無向辺を張る．",
			"    void add_edge(int u, int v, T cost) {",
			"        assert(0 <= u and u < order());",
			"        assert(0 <= v and v < order());",
			"        m_g[u].emplace_back(v, cost);",
			"        m_g[v].emplace_back(u, cost);",
			"    }",
			"    // 重み付き無向連結グラフにおける最小全域木のコストを求める．O(|E|*log|V|).",
			"    T prim(int rt = 0) {",
			"        assert(0 <= rt and rt < order());",
			"        T res = 0;",
			"        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, std::greater<std::pair<T, int> > > pque;",
			"        pque.emplace(0, rt);",
			"        std::vector<bool> seen(order(), false);",
			"        while(!pque.empty()) {",
			"            auto [cost, u] = pque.top();",
			"            pque.pop();",
			"            if(seen[u]) continue;",
			"            seen[u] = true;",
			"            res += cost;",
			"            for(const auto &[v, cost] : m_g[u]) {",
			"                if(!seen[v]) pque.emplace(cost, v);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Prim's Algorithm（最小全域木）"
	},
	"PrimalDual": {
		"scope": "cpp",
		"prefix": "PrimalDual",
		"body": [
			"template <typename Flow, typename Cost>  // Flow:容量の型, Cost:コストの型.",
			"class PrimalDual {",
			"    struct Edge {",
			"        int to;     // to:=(行き先ノード).",
			"        Flow cap;   // cap:=(容量).",
			"        Cost cost;  // cost:=(単位コスト).",
			"        int rev;    // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, Flow cap_, Cost cost_, int rev_) : to(to_), cap(cap_), cost(cost_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[i]:=(i番目の辺情報). pair of (from, index).",
			"",
			"    static constexpr Cost infinity_cost() { return std::numeric_limits<Cost>::max(); }",
			"    void dijkstra(int s, const std::vector<Cost> &h, std::vector<Cost> &d, std::vector<int> &prev_v, std::vector<int> &prev_e,",
			"                  std::priority_queue<std::pair<Cost, int>, std::vector<std::pair<Cost, int> >, std::greater<std::pair<Cost, int> > > &pque) {",
			"        std::fill(d.begin(), d.end(), infinity_cost());",
			"        d[s] = 0;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(d[v] < dist) continue;",
			"            for(int i = 0, n = m_g[v].size(); i < n; ++i) {",
			"                const Edge &e = m_g[v][i];",
			"                Cost new_cost = e.cost + h[v] - h[e.to];",
			"                if(e.cap > 0 and d[e.to] > d[v] + new_cost) {",
			"                    d[e.to] = d[v] + new_cost;",
			"                    prev_v[e.to] = v;",
			"                    prev_e[e.to] = i;",
			"                    pque.emplace(d[e.to], e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    PrimalDual() : PrimalDual(0) {}",
			"    explicit PrimalDual(size_t vn) : m_g(vn) {}",
			"    explicit PrimalDual(size_t vn, size_t en) : PrimalDual(vn) {",
			"        m_pos.reserve(en);",
			"    }",
			"",
			"    static constexpr Flow infinity_flow() { return std::numeric_limits<Flow>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す.",
			"    int size() const { return m_pos.size(); }",
			"    // 容量cap[flows]，単位コストcost[cost/flow]の有向辺を追加する．",
			"    int add_edge(int from, int to, Flow cap, Cost cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        assert(cost >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, cost, idx_to);",
			"        m_g[to].emplace_back(from, 0, -cost, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ソースからシンクまでの最小費用[costs]（単位コスト[cost/flow]とフロー[flows]の積の総和）を求める．",
			"    // 返り値は流量[flows]と最小費用[costs]．O(F*|E|*log|V|).",
			"    std::pair<Flow, Cost> min_cost_flow(int s, int t) { return slope(s, t, infinity_flow()).back(); }",
			"    std::pair<Flow, Cost> min_cost_flow(int s, int t, Flow flow) { return slope(s, t, flow).back(); }",
			"    std::vector<std::pair<Flow, Cost> > slope(int s, int t) { return slope(s, t, infinity_flow()); }",
			"    std::vector<std::pair<Flow, Cost> > slope(int s, int t, Flow flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        Flow rest = flow;                                   // rest:=(残流量).",
			"        Cost sum = 0;                                       // sum:=(合計費用).",
			"        Cost prev_cost = -1;                                // prev_cost:=(直前のフローにおける単位コスト[cost/flow]).",
			"        std::vector<std::pair<Flow, Cost> > res({{0, 0}});  // res[]:=(流量とコストの関係の折れ線). 値は狭義単調増加．",
			"        std::vector<Cost> d(order());                       // d[v]:=(ノートsからvまでの最小単位コスト).",
			"        std::vector<Cost> h(order(), 0);                    // h[v]:=(ノードvのポテンシャル).",
			"        std::vector<int> prev_v(order());                   // prev_v[v]:=(ノードvの直前に訪れるノード). 逆方向経路．",
			"        std::vector<int> prev_e(order());                   // prev_e[v]:=(ノードvの直前に通る辺). 逆方向経路．",
			"        std::priority_queue<std::pair<Cost, int>, std::vector<std::pair<Cost, int> >, std::greater<std::pair<Cost, int> > > pque;",
			"        while(rest > 0) {",
			"            dijkstra(s, h, d, prev_v, prev_e, pque);",
			"            if(d[t] == infinity_cost()) break;  // これ以上流せない場合．",
			"            for(int v = 0, n = order(); v < n; ++v) h[v] += d[v];",
			"            Flow tmp = rest;",
			"            for(int v = t; v != s; v = prev_v[v]) tmp = std::min(tmp, m_g[prev_v[v]][prev_e[v]].cap);",
			"            rest -= tmp;",
			"            sum += h[t] * tmp;",
			"            if(h[t] == prev_cost) res.pop_back();",
			"            res.emplace_back(flow - rest, sum);",
			"            for(int v = t; v != s; v = prev_v[v]) {",
			"                Edge &e = m_g[prev_v[v]][prev_e[v]];",
			"                e.cap -= tmp;",
			"                m_g[v][e.rev].cap += tmp;",
			"            }",
			"            prev_cost = h[t];",
			"        }",
			"        return res;",
			"    }",
			"    // i番目の辺情報を返す．",
			"    std::tuple<int, int, Flow, Cost, Flow> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, e.cost, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, cost, flow).",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "最小費用流問題"
	},
	"RollbackUnionFind": {
		"scope": "cpp",
		"prefix": "RollbackUnionFind",
		"body": [
			"// Rollback付きUnion-Find．",
			"class RollbackUnionFind {",
			"    int m_vn;  // m_vn:=(要素数).",
			"    int m_gn;  // m_gn:=(グループ数).",
			"    // m_par[x]:=(要素xの親). 0未満の場合，xは根であり，値の絶対値は属するグループのサイズを表す．",
			"    std::vector<int> m_par;",
			"    std::stack<std::tuple<int, int, int, int> > m_history;  // tuple of (x, m_par[x], y, m_par[y]).",
			"",
			"public:",
			"    RollbackUnionFind() : RollbackUnionFind(0) {}",
			"    explicit RollbackUnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // 現在のヒストリーのインデックスを返す．O(1).",
			"    int index() const { return m_history.size(); }",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 要素xが属するグループ（根付き木）の根を返す．O(logN).",
			"    int root(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        if(m_par[x] < 0) return x;",
			"        return root(m_par[x]);",
			"    }",
			"    // 要素xが属するグループのサイズを返す．O(logN).",
			"    int size(int x) const {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)];",
			"    }",
			"    // 要素x, yが同じグループに属するか判定する．O(logN).",
			"    bool is_same(int x, int y) const {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 要素x, yが属するそれぞれのグループを併合する．O(logN).",
			"    bool unite(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        x = root(x), y = root(y);",
			"        m_history.emplace(x, m_par[x], y, m_par[y]);",
			"        if(x == y) return false;",
			"        if(size(x) < size(y)) std::swap(x, y);  // Merge technique (union by size).",
			"        m_par[x] += m_par[y];",
			"        m_par[y] = x;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    // 直前の状態に戻す．O(1).",
			"    void rollback() {",
			"        assert(index() >= 1);",
			"        auto [x, value_x, y, value_y] = m_history.top();",
			"        m_history.pop();",
			"        m_par[x] = value_x, m_par[y] = value_y;",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"        std::stack<std::tuple<int, int, int, int> >().swap(m_history);",
			"    }",
			"};"
		],
		"description": "Rollback付きUnion-Find"
	},
	"SCC": {
		"scope": "cpp",
		"prefix": "SCC",
		"body": [
			"// Strongly Connected Components（強連結成分分解）.",
			"class SCC {",
			"    int m_vn;                            // m_vn:=(ノード数).",
			"    std::vector<std::vector<int> > m_g;  // m_g[v][]:=(ノードvの隣接リスト).",
			"",
			"public:",
			"    SCC() : SCC(0) {}",
			"    explicit SCC(int vn) : m_vn(vn), m_g(vn) {}",
			"",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 有向辺を張る．",
			"    void add_edge(int from, int to) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_g[from].push_back(to);",
			"    }",
			"    // 有向グラフを強連結成分分解する．return pair of (# of SCCs, SCC id of each nodes). O(|V|+|E|).",
			"    std::pair<int, std::vector<int> > decompose() const {",
			"        int num_sccs = 0;               // num_sccs:=(SCCの数).",
			"        std::vector<int> ids(order());  // ids[v]:=(ノードvが属するSCCのID).",
			"        // ord[v]:=(DFS木におけるノードvの行きがけ順序).",
			"        // low[v]:=(DFS木において，ノードvから葉方向への辺を0回以上，後退辺を高々1回用いて到達できるノードwに対するord[w]の最小値).",
			"        std::vector<int> ord(order(), -1), low(order());",
			"        int now = 0;",
			"        std::stack<int> visited;",
			"        auto dfs = [&](auto self, int u) -> void {",
			"            ord[u] = low[u] = now++;",
			"            visited.push(u);",
			"            for(int to : m_g[u]) {",
			"                if(ord[to] == -1) {",
			"                    self(self, to);",
			"                    low[u] = std::min(low[u], low[to]);",
			"                } else {",
			"                    low[u] = std::min(low[u], ord[to]);",
			"                }",
			"            }",
			"            if(low[u] == ord[u]) {",
			"                while(true) {",
			"                    int v = visited.top();",
			"                    visited.pop();",
			"                    ord[v] = order();  // inf.",
			"                    ids[v] = num_sccs;",
			"                    if(v == u) break;",
			"                }",
			"                num_sccs++;",
			"            }",
			"        };",
			"        for(int v = 0; v < order(); ++v) {",
			"            if(ord[v] == -1) dfs(dfs, v);",
			"        }",
			"        return {num_sccs, ids};",
			"    }",
			"    // 強連結成分ごとに各ノードをグループ分けする．",
			"    std::vector<std::vector<int> > scc() const { return scc(decompose()); }",
			"    std::vector<std::vector<int> > scc(const std::pair<int, std::vector<int> > &p) const { return scc(p.first, p.second); }",
			"    std::vector<std::vector<int> > scc(int num, const std::vector<int> &ids) const {",
			"        assert((int)ids.size() == order());",
			"        std::vector<std::vector<int> > sccs(num);",
			"        for(int v = 0; v < order(); ++v) {",
			"            assert(0 <= ids[v] and ids[v] < num);",
			"            sccs[ids[v]].push_back(v);",
			"        }",
			"        return sccs;",
			"    }",
			"    // 強連結成分から構成されるDAGを取得する．",
			"    std::vector<std::vector<int> > directed_acyclic_graph(const std::pair<int, std::vector<int> > &p) const { return directed_acyclic_graph(p.first, p.second); }",
			"    std::vector<std::vector<int> > directed_acyclic_graph(int num, const std::vector<int> &ids) const {",
			"        assert((int)ids.size() == order());",
			"        std::vector<std::vector<int> > dag(num);",
			"        for(int u = 0; u < order(); ++u) {",
			"            assert(0 <= ids[u] and ids[u] < num);",
			"            for(int v : m_g[u]) {",
			"                assert(0 <= ids[v] and ids[v] < num);",
			"                if(ids[v] == ids[u]) continue;",
			"                dag[ids[u]].push_back(ids[v]);",
			"            }",
			"        }",
			"        for(std::vector<int> &edge : dag) {",
			"            std::sort(edge.begin(), edge.end());",
			"            edge.erase(std::unique(edge.begin(), edge.end()), edge.end());",
			"        }",
			"        return dag;",
			"    }",
			"};"
		],
		"description": "Strongly Connected Components（強連結成分分解）"
	},
	"SegmentSieve": {
		"scope": "cpp",
		"prefix": "SegmentSieve",
		"body": [
			"// 区間篩．",
			"class SegmentSieve {",
			"    long long m_l, m_r;",
			"    long long m_sr;                                 // m_sr:=√r.",
			"    std::vector<long long> m_small;                 // m_small[n]:=(区間[2,√r)の自然数nにおける最小素因数).",
			"    std::vector<std::map<long long, int>> m_large;  // m_large[n-l][]:=(区間[l,r)の自然数nにおける区間[2,√r)のいくつかの素因数).",
			"    std::vector<long long> m_aux;                   // m_aux[n-l]:=(m_large[n-l][]の積).",
			"",
			"public:",
			"    // constructor. 区間[l,r)の自然数を篩にかける．制約の目安はおおよそ 2<=l<r<=1e12, r-l<=1e6．",
			"    SegmentSieve() : SegmentSieve(2, 3) {}",
			"    explicit SegmentSieve(long long l, long long r) : m_l(l), m_r(r) {",
			"        assert(2 <= l and l < r);",
			"        m_sr = std::sqrt(m_r) + 1;",
			"        m_small.assign(m_sr, -1);",
			"        std::iota(m_small.begin() + 2, m_small.end(), 2);",
			"        m_large.resize(r - l);",
			"        m_aux.assign(r - l, 1);",
			"        for(long long p = 2; p * p < m_r; ++p) {",
			"            if(m_small[p] == p) {",
			"                for(long long q = p * p; q < m_sr; q += p) m_small[q] = p;",
			"                for(long long q = std::max((m_l + p - 1) / p, 2LL) * p; q < m_r; q += p) {",
			"                    long long tmp = q;",
			"                    while(m_aux[q - m_l] * m_aux[q - m_l] < m_r and tmp % p == 0) {",
			"                        ++m_large[q - m_l][p];",
			"                        m_aux[q - m_l] *= p;",
			"                        tmp /= p;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        return m_large[n - m_l].size() == 0;",
			"    }",
			"    // 高速素因数分解．",
			"    std::map<long long, int> prime_factorize(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        std::map<long long, int> res = m_large[n - m_l];",
			"        n /= m_aux[n - m_l];",
			"        if(n >= m_sr) {",
			"            ++res[n];",
			"            return res;",
			"        }",
			"        while(n > 1) {",
			"            ++res[m_small[n]];",
			"            n /= m_small[n];",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "区間篩"
	},
	"Sieve": {
		"scope": "cpp",
		"prefix": "Sieve",
		"body": [
			"// Sieve of Eratosthenes（エラトステネスの篩）.",
			"class Sieve {",
			"    int m_sz;",
			"    // m_lpf[i]:=(正の奇数2*i+1の最小素因数). Least prime factor. m_lpf[i]==2*i+1 のとき，2*i+1は素数．",
			"    std::vector<int> m_lpf;",
			"",
			"public:",
			"    // constructor. n未満の自然数を篩にかける．O(N*loglogN).",
			"    Sieve() : Sieve(0) {}",
			"    explicit Sieve(int n) : m_sz(n), m_lpf(n / 2, -1) {",
			"        assert(n >= 0);",
			"        for(long long p = 3; p < m_sz; p += 2) {",
			"            if(m_lpf[p / 2] == -1) {",
			"                m_lpf[p / 2] = p;",
			"                for(long long q = p * p; q < m_sz; q += 2 * p) {",
			"                    if(m_lpf[q / 2] == -1) m_lpf[q / 2] = p;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    int size() const { return m_sz; }",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n < size());",
			"        if(n == 2) return true;",
			"        if(n % 2 == 0) return false;",
			"        return m_lpf[n / 2] == n;",
			"    }",
			"    // 自然数nの最小素因数を取得する．O(1).",
			"    int lpf(int n) const {",
			"        assert(0 <= n and n < size());",
			"        if(n < 2) return -1;",
			"        if(n % 2 == 0) return 2;",
			"        return m_lpf[n / 2];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n < size());",
			"        std::map<int, int> res;",
			"        for(; n % 2 == 0; n /= 2) ++res[2];",
			"        for(; n > 1; n /= m_lpf[n / 2]) ++res[m_lpf[n / 2]];",
			"        return res;",
			"    }",
			"    // オイラーのファイ関数．n以下でnと互いに素な自然数の個数を求める．O(logN).",
			"    int totient(int n) const {",
			"        assert(1 <= n and n < size());",
			"        int res = n;",
			"        for(const auto &[p, _] : prime_factorize(n)) res -= res / p;",
			"        return res;",
			"    }",
			"    // メビウス関数．O(N*loglogN).",
			"    std::vector<int> mobius() const {",
			"        std::vector<int> res(m_sz, 1);  // res[n]:=μ(n).",
			"        for(int p = 2; p < m_sz; ++p) {",
			"            if(lpf(p) == p) {",
			"                res[p] = -1;",
			"                for(int q = 2 * p; q < m_sz; q += p) {",
			"                    if((q / p) % p == 0) res[q] = 0;  // nがある素数pで2回以上割り切れるとき，μ(n)=0.",
			"                    else res[q] = -res[q];            // nがk個の相異なる素因数で分解できるとき，μ(n)=(-1)^k.",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Sieve of Eratosthenes（エラトステネスの篩）"
	},
	"TopologicalSort": {
		"scope": "cpp",
		"prefix": "TopologicalSort",
		"body": [
			"class TopologicalSort {",
			"    int m_vn;                            // m_vn:=(ノード数).",
			"    std::vector<std::vector<int> > m_g;  // m_g[v]:=(ノードvの隣接リスト).",
			"",
			"public:",
			"    TopologicalSort() : TopologicalSort(0) {}",
			"    explicit TopologicalSort(size_t vn) : m_vn(vn), m_g(vn) {}",
			"",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 有向辺を張る．",
			"    void add_edge(int from, int to) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_g[from].push_back(to);",
			"    }",
			"    // 有向非巡回グラフに対する任意のトポロジカルソートの解を求める．O(|V|+|E|).",
			"    std::vector<int> topological_sort() const {",
			"        std::vector<int> res;",
			"        res.reserve(order());",
			"        std::vector<int> deg(order(), 0);  // deg[v]:=(ノードvの入次数).",
			"        for(const std::vector<int> &edges : m_g) {",
			"            for(int to : edges) deg[to]++;",
			"        }",
			"        std::queue<int> que;",
			"        for(int i = 0; i < order(); ++i) {",
			"            if(deg[i] == 0) que.push(i);",
			"        }",
			"        while(!que.empty()) {",
			"            int u = que.front();",
			"            que.pop();",
			"            res.push_back(u);",
			"            for(int v : m_g[u]) {",
			"                if(--deg[v] == 0) que.push(v);",
			"            }",
			"        }",
			"        if((int)res.size() != order()) return std::vector<int>();  // 閉路がある場合．",
			"        return res;",
			"    }",
			"    // 考え得るトポロジカルソートの解を数え上げる．ノード数の実用上限目安は20程度．O(N*(2^N)).",
			"    template <typename Type = long long>",
			"    Type count_up() const {",
			"        assert(order() <= 30);",
			"        const int n = order();",
			"        std::vector<int> b(n, 0);  // b[v]:=(ノードvの隣接リストにある行き先ノードの集合).",
			"        for(int v = 0; v < n; ++v) {",
			"            for(int to : m_g[v]) b[v] |= 1 << to;",
			"        }",
			"        std::vector<Type> dp(1 << n, 0);  // dp[S]:=(ノード集合Sにおける解の通り数).",
			"        dp[0] = 1;",
			"        for(int bit = 0; bit < 1 << n; ++bit) {",
			"            for(int i = 0; i < n; ++i) {",
			"                if(!(bit >> i & 1) and !(bit & b[i])) dp[bit | 1 << i] += dp[bit];",
			"            }",
			"        }",
			"        return dp[(1 << n) - 1];",
			"    }",
			"};"
		],
		"description": "Topological Sort（トポロジカルソート）"
	},
	"Trie": {
		"scope": "cpp",
		"prefix": "Trie",
		"body": [
			"// Trie木．",
			"template <char BASE = 0, size_t N = 128>",
			"class Trie {",
			"public:",
			"    using size_type = size_t;",
			"",
			"private:",
			"    struct Node {",
			"        size_type cnt;             // cnt:=(自身を末尾とする要素の数).",
			"        size_type total;           // total:=(自身を根とする部分木に含まれる要素の数).",
			"        std::array<Node *, N> ch;  // ch[]:=(子のポインタ).",
			"",
			"        Node() : cnt(0), total(0) {",
			"            std::fill(ch.begin(), ch.end(), nullptr);",
			"        }",
			"",
			"        Node *&child(char key) { return ch.at(key - BASE); }",
			"        const Node *&child(char key) const { return ch.at(key - BASE); }",
			"    };",
			"",
			"    Node *m_root;  // m_root:=(根のポインタ).",
			"",
			"    Node *find(std::string_view sv) const {",
			"        if(!m_root) return nullptr;",
			"        Node *p = m_root;",
			"        for(char c : sv) {",
			"            p = p->child(c);",
			"            if(!p) return nullptr;",
			"        }",
			"        return p;",
			"    }",
			"    Node *add(Node *p, std::string_view sv, int n, size_type cnt, int i = 0) {  // top down.",
			"        if(!p) p = new Node();",
			"        if(i == n) {",
			"            p->cnt += cnt, p->total += cnt;",
			"            return p;",
			"        }",
			"        p->total += cnt;",
			"        p->child(sv[i]) = add(p->child(sv[i]), sv, n, cnt, i + 1);",
			"        return p;",
			"    }",
			"    Node *sub(Node *p, std::string_view sv, int n, size_type cnt, int i = 0) {  // bottom up.",
			"        assert(p and p->total >= cnt);",
			"        if(i < n) p->child(sv[i]) = sub(p->child(sv[i]), sv, n, cnt, i + 1);",
			"        else p->cnt -= cnt;",
			"        p->total -= cnt;",
			"        if(p->total == 0) {",
			"            delete p;",
			"            p = nullptr;",
			"        }",
			"        return p;",
			"    }",
			"    Node *erase_prefix_internal(Node *p, std::string_view sv, int n, int i = 0) {  // bottom up.",
			"        if(!p) return nullptr;",
			"        if(i == n) return clear_dfs(p);",
			"        if(!p->child(sv[i])) return p;",
			"        size_type pre = p->child(sv[i])->total;",
			"        p->child(sv[i]) = erase_prefix_internal(p->child(sv[i]), sv, n, i + 1);",
			"        p->total -= pre - (p->child(sv[i]) ? p->child(sv[i])->total : 0);",
			"        if(p->total == 0) {",
			"            delete p;",
			"            p = nullptr;",
			"        }",
			"        return p;",
			"    }",
			"    std::pair<size_type, size_type> get_lower_and_upper(std::string_view sv) const {",
			"        if(!m_root) return {0, 0};",
			"        size_type itr = 0;",
			"        Node *p = m_root;",
			"        for(char c : sv) {",
			"            itr += p->cnt;",
			"            for(char d = BASE; d < c; ++d) {",
			"                if(p->child(d)) itr += p->child(d)->total;",
			"            }",
			"            p = p->child(c);",
			"            if(!p) break;",
			"        }",
			"        return {itr, itr + (p ? p->cnt : 0)};",
			"    }",
			"    void get(Node *p, size_type k, std::string &s, int i = 0) const {",
			"        assert(p);",
			"        if(k < p->cnt) {",
			"            s.resize(i);",
			"            return;",
			"        }",
			"        k -= p->cnt;",
			"        for(size_t j = 0; j < N; ++j) {",
			"            if(!p->ch[j]) continue;",
			"            if(k < p->ch[j]->total) {",
			"                get(p->ch[j], k, s, i + 1);",
			"                s[i] = BASE + j;",
			"                return;",
			"            }",
			"            k -= p->ch[j]->total;",
			"        }",
			"        assert(false);  // not reach here.",
			"    }",
			"    Node *clear_dfs(Node *p) {",
			"        if(!p) return nullptr;",
			"        for(Node *&next : p->ch) next = clear_dfs(next);",
			"        delete p;",
			"        return p = nullptr;",
			"    }",
			"",
			"public:",
			"    Trie() : m_root(nullptr) {}",
			"    ~Trie() {",
			"        clear();",
			"    }",
			"",
			"    std::string operator[](size_type k) const { return kth_element(k); }",
			"",
			"    // 集合が空かどうか判定する．O(1).",
			"    bool empty() const { return size() == 0; }",
			"    // 全要素数を返す．O(1).",
			"    size_type size() const { return (m_root ? m_root->total : 0); }",
			"    // 文字列svが集合に含まれるか判定する．O(|S|).",
			"    size_type exists(std::string_view sv) const { return count(sv) > 0; }",
			"    // 接頭辞がsvである文字列が集合に含まれるか判定する．O(|S|).",
			"    size_type exists_prefix(std::string_view sv) const { return count_prefix(sv) > 0; }",
			"    // 文字列svの要素数を返す．O(|S|).",
			"    size_type count(std::string_view sv) const {",
			"        Node *p = find(sv);",
			"        return (p ? p->cnt : 0);",
			"    }",
			"    // 接頭辞がsvである文字列の要素数を返す．O(|S|).",
			"    size_type count_prefix(std::string_view sv) const {",
			"        Node *p = find(sv);",
			"        return (p ? p->total : 0);",
			"    }",
			"    // 多重集合に文字列svを追加する．O(|S|).",
			"    void insert(std::string_view sv, size_type cnt = 1) {",
			"        if(cnt == 0) return;",
			"        m_root = add(m_root, sv, sv.size(), cnt);",
			"    }",
			"    // 多重集合から文字列svを削除する．O(|S|).",
			"    void erase(std::string_view sv) { erase(sv, count(sv)); }",
			"    void erase(std::string_view sv, size_type cnt) {",
			"        assert(count(sv) >= cnt);",
			"        if(cnt == 0) return;",
			"        m_root = sub(m_root, sv, sv.size(), cnt);",
			"    }",
			"    // 多重集合から接頭辞がsvである文字列を削除する．O(|S|*N).",
			"    void erase_prefix(std::string_view sv) { m_root = erase_prefix_internal(m_root, sv, sv.size()); }",
			"    // 辞書順でsv以上である文字列とsvより大きい文字列が現れる先頭の位置を取得する．O(|S|*N).",
			"    std::pair<size_type, size_type> lower_and_upper_bound(std::string_view sv) const { return get_lower_and_upper(sv); }",
			"    // 多重集合内において辞書順でk番目に小さい文字列を取得する．0-based index. O(|S|*N).",
			"    std::string kth_element(size_type k) const {",
			"        assert(k < size());",
			"        std::string res;",
			"        get(m_root, k, res);",
			"        return res;",
			"    }",
			"    // 集合内において辞書順で最小の文字列を取得する．O(|S|*N).",
			"    std::string min_element() const { return kth_element(0); }",
			"    // 集合内において辞書順で最大の文字列を取得する．O(|S|*N).",
			"    std::string max_element() const { return kth_element(size() - 1); }",
			"    // 全要素を削除する．O(|S|*N).",
			"    void clear() { m_root = clear_dfs(m_root); }",
			"};",
			"",
			"using DefaultTrie = Trie<'A', 58>;",
			"using DefaultTrie2 = Trie<'0', 75>;"
		],
		"description": "Trie木"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "UnionFind",
		"body": [
			"class UnionFind {",
			"    int m_vn;  // m_vn:=(要素数).",
			"    int m_gn;  // m_gn:=(グループ数).",
			"    // m_par[x]:=(要素xの親). 0未満の場合，xは根であり，値の絶対値は属するグループのサイズを表す．",
			"    std::vector<int> m_par;",
			"",
			"public:",
			"    UnionFind() : UnionFind(0) {}",
			"    explicit UnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 要素xが属するグループ（根付き木）の根を返す．O(α(N)).",
			"    int root(int x) {",
			"        assert(0 <= x and x < vn());",
			"        if(m_par[x] < 0) return x;",
			"        return m_par[x] = root(m_par[x]);  // 経路圧縮．",
			"    }",
			"    // 要素xが属するグループのサイズを返す．",
			"    int size(int x) {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)];",
			"    }",
			"    // 要素x, yが同じグループに属するか判定する．",
			"    bool is_same(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 要素x, yが属するそれぞれのグループを併合する．",
			"    bool unite(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;                    // Do nothing.",
			"        if(-m_par[x] < -m_par[y]) std::swap(x, y);  // Merge technique (union by size).",
			"        m_par[x] += m_par[y];",
			"        m_par[y] = x;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"    }",
			"};"
		],
		"description": "Union-Find（素集合データ構造）"
	},
	"bisearch": {
		"scope": "cpp",
		"prefix": "bisearch",
		"body": [
			"template <std::integral Type, class Pred>",
			"constexpr Type bisearch(Type ok, Type ng, Pred pred) {",
			"    static_assert(std::is_convertible_v<Pred, std::function<bool(Type)>>);",
			"    assert(ok <= ng);",
			"    if(!pred(ok)) return ok;",
			"    while(ng - ok > 1) {",
			"        Type mid = std::midpoint(ok, ng);",
			"        (pred(mid) ? ok : ng) = mid;",
			"    }",
			"    return ng;",
			"}",
			"",
			"template <std::floating_point Type, class Pred>",
			"constexpr Type bisearch(Type ok, Type ng, Type eps, Pred pred) {",
			"    static_assert(std::is_convertible_v<Pred, std::function<bool(Type)>>);",
			"    assert(ok <= ng);",
			"    if(!pred(ok)) return ok;",
			"    while(ng - ok > eps) {",
			"        Type mid = std::midpoint(ok, ng);",
			"        (pred(mid) ? ok : ng) = mid;",
			"    }",
			"    return ng;",
			"}"
		],
		"description": "Binary Search（二分探索）"
	},
	"compress": {
		"scope": "cpp",
		"prefix": "compress",
		"body": [
			"// 座標圧縮．O(N*logN).",
			"template <typename Type>",
			"std::vector<Type> compress(std::vector<Type> &v) {",
			"    std::vector<Type> key(v);",
			"    std::sort(key.begin(), key.end());",
			"    key.erase(std::unique(key.begin(), key.end()), key.end());",
			"    key.shrink_to_fit();",
			"    for(auto &elem : v) elem = std::lower_bound(key.cbegin(), key.cend(), elem) - key.cbegin();",
			"    return key;",
			"}"
		],
		"description": "座標圧縮"
	},
	"divisors": {
		"scope": "cpp",
		"prefix": "divisors",
		"body": [
			"// 約数列挙．O(√N).",
			"template <typename Type>",
			"std::vector<Type> divisors(Type n) {",
			"    assert(n >= 1);",
			"    std::vector<Type> res;  // res[]:=(自然数nの約数の集合).",
			"    for(Type p = 1; p * p <= n; ++p) {",
			"        if(n % p == 0) {",
			"            res.push_back(p);",
			"            Type q = n / p;",
			"            if(q != p) res.push_back(q);",
			"        }",
			"    }",
			"    std::sort(res.begin(), res.end());",
			"    return res;",
			"}",
			"",
			"// 高速約数列挙．",
			"template <typename Type>",
			"std::vector<Type> divisors(const std::map<Type, int> &pf) {",
			"    std::vector<Type> res({1});",
			"    for(const auto &[p, cnt] : pf) {",
			"        const int sz = res.size();",
			"        Type b = 1;",
			"        for(int i = 0; i < cnt; ++i) {",
			"            b *= p;",
			"            for(int j = 0; j < sz; ++j) res.push_back(res[j] * b);",
			"        }",
			"    }",
			"    std::sort(res.begin(), res.end());",
			"    return res;",
			"}"
		],
		"description": "約数列挙"
	},
	"double_sweep": {
		"scope": "cpp",
		"prefix": "double_sweep",
		"body": [
			"// 木の直径を求める．返り値は直径とその経路．O(|V|).",
			"std::pair<int, std::vector<int> > double_sweep(const std::vector<std::vector<int> > &g, int s = 0) {",
			"    const int vn = g.size();",
			"    assert(0 <= s and s < vn);",
			"    int furthest_node;",
			"    std::vector<int> d(vn);",
			"    std::vector<int> pre(vn);",
			"    std::queue<int> que;",
			"    auto bfs = [&](int s) -> void {",
			"        std::fill(pre.begin(), pre.end(), -1);",
			"        d[s] = 0, pre[s] = -2;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int u = que.front();",
			"            que.pop();",
			"            furthest_node = u;",
			"            for(int v : g[u]) {",
			"                assert(0 <= v and v < vn);",
			"                if(pre[v] != -1) continue;",
			"                d[v] = d[u] + 1, pre[v] = u;",
			"                que.push(v);",
			"            }",
			"        }",
			"    };",
			"    bfs(s);",
			"    bfs(furthest_node);",
			"    std::vector<int> path({furthest_node});",
			"    path.reserve(d[furthest_node] + 1);",
			"    for(int v = furthest_node; pre[v] != -2; v = pre[v]) path.push_back(pre[v]);",
			"    return {d[furthest_node], path};  // pair of (diameter, path).",
			"}",
			"",
			"// 重み付き木の直径を求める．返り値は直径とその経路．O(|V|).",
			"template <typename Type>",
			"std::pair<Type, std::vector<int> > double_sweep(const std::vector<std::vector<std::pair<int, Type> > > &g, int s = 0) {",
			"    const int vn = g.size();",
			"    assert(0 <= s and s < vn);",
			"    int furthest_node;",
			"    std::vector<Type> d(vn);",
			"    std::vector<int> pre(vn);",
			"    std::queue<int> que;",
			"    auto bfs = [&](int s) -> void {",
			"        furthest_node = s;",
			"        std::fill(pre.begin(), pre.end(), -1);",
			"        d[s] = 0, pre[s] = -2;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int u = que.front();",
			"            que.pop();",
			"            if(d[u] > d[furthest_node]) furthest_node = u;",
			"            for(const auto &[v, cost] : g[u]) {",
			"                assert(0 <= v and v < vn);",
			"                if(pre[v] != -1) continue;",
			"                d[v] = d[u] + cost, pre[v] = u;",
			"                que.push(v);",
			"            }",
			"        }",
			"    };",
			"    bfs(s);",
			"    bfs(furthest_node);",
			"    std::vector<int> path({furthest_node});",
			"    for(int v = furthest_node; pre[v] != -2; v = pre[v]) path.push_back(pre[v]);",
			"    return {d[furthest_node], path};  // pair of (diameter, path).",
			"}"
		],
		"description": "Double Sweep（木の直径）"
	},
	"edit_distance": {
		"scope": "cpp",
		"prefix": "edit_distance",
		"body": [
			"// 2つの配列に対して，編集距離 (Edit Distance) を求める．",
			"// 引数はSTLのシーケンスコンテナであること．O(|S|*|T|).",
			"template <class Sequence>",
			"int edit_distance(const Sequence &s, const Sequence &t) {",
			"    const int n = s.size(), m = t.size();",
			"    // dp[i][j]:=(s[:i]とt[:j]の編集距離).",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));",
			"    for(int i = 1; i <= n; ++i) dp[i][0] = i;",
			"    for(int j = 1; j <= m; ++j) dp[0][j] = j;",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < m; ++j) {",
			"            dp[i + 1][j + 1] = std::min({dp[i][j + 1] + 1,",
			"                                         dp[i + 1][j] + 1,",
			"                                         dp[i][j] + (s[i] == t[j] ? 0 : 1)});",
			"        }",
			"    }",
			"    return dp[n][m];",
			"}"
		],
		"description": "Edit Distance（編集距離）"
	},
	"extgcd": {
		"scope": "cpp",
		"prefix": "extgcd",
		"body": [
			"// 拡張ユークリッドの互除法．",
			"// ax+by=gcd(a,b) を満たす整数の組(x,y)を求め，gcd(a,b)を返す．O(log(min(a,b))).",
			"template <typename Type>",
			"Type extgcd(Type a, Type b, Type &x, Type &y) {",
			"    if(b == 0) {",
			"        x = 1, y = 0;",
			"        return a;",
			"    }",
			"    Type &&d = extgcd(b, a % b, y, x);",
			"    y -= a / b * x;",
			"    return d;",
			"}"
		],
		"description": "拡張ユークリッドの互除法"
	},
	"pow": {
		"scope": "cpp",
		"prefix": "pow",
		"body": [
			"// 繰り返し二乗法．O(logK).",
			"template <typename Type>",
			"constexpr Type pow(Type n, long long k) {",
			"    assert(k >= 0);",
			"    Type res = 1;",
			"    while(k > 0) {",
			"        if(k & 1LL) res *= n;",
			"        n *= n;",
			"        k >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "繰り返し二乗法"
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"// 素数判定．O(√N).",
			"template <typename Type>",
			"constexpr bool is_prime(Type n) {",
			"    assert(n >= 0);",
			"    if(n < 2) return false;",
			"    if(n == 2) return true;",
			"    if(n % 2 == 0) return false;",
			"    for(Type p = 3; p * p <= n; p += 2) {",
			"        if(n % p == 0) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "素数判定"
	},
	"largest_rectangle": {
		"scope": "cpp",
		"prefix": "largest_rectangle",
		"body": [
			"// 最大長方形問題．",
			"// 各iにおいて，comp(H[i], H[] within [l,r))==true となるiを含む最大区間[l,r)を求める．O(N).",
			"template <typename Type, class Compare = std::function<bool(const Type &, const Type &)> >",
			"std::vector<std::pair<int, int> > largest_rectangle(",
			"    const std::vector<Type> &h,",
			"    const Compare &comp = [](const Type &a, const Type &b) -> bool { return a <= b; }) {",
			"    const int n = h.size();",
			"    std::vector<std::pair<int, int> > res(n, {0, n});  // res[i]:=(pair of [l,r)).",
			"    std::stack<std::pair<Type, int> > st;",
			"    // left side.",
			"    for(int i = 0; i < n; ++i) {",
			"        while(!st.empty() and comp(h[i], st.top().first)) st.pop();",
			"        if(!st.empty()) res[i].first = st.top().second + 1;",
			"        st.push({h[i], i});",
			"    }",
			"    // right side.",
			"    st = std::stack<std::pair<Type, int> >();",
			"    for(int i = n - 1; i >= 0; --i) {",
			"        while(!st.empty() and comp(h[i], st.top().first)) st.pop();",
			"        if(!st.empty()) res[i].second = st.top().second;",
			"        st.push({h[i], i});",
			"    }",
			"    return res;",
			"}"
		],
		"description": "最大長方形問題"
	},
	"lcs": {
		"scope": "cpp",
		"prefix": "lcs",
		"body": [
			"// 2つの配列に対して，最長共通部分列 (LCS: Longest Common Subsequence) を求める．",
			"// 引数はSTLのシーケンスコンテナであること．O(|S|*|T|).",
			"template <class Sequence>",
			"Sequence lcs(const Sequence &s, const Sequence &t) {",
			"    const int n = s.size(), m = t.size();",
			"    // dp[i][j]:=(s[:i]とt[:j]のLCSの長さ).",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < m; ++j) {",
			"            dp[i + 1][j + 1] = (s[i] == t[j] ? dp[i][j] + 1 : std::max(dp[i][j + 1], dp[i + 1][j]));",
			"        }",
			"    }",
			"    Sequence sub(dp[n][m], 0);  // sub[]:=(配列s, tのLCS).",
			"    int i = n - 1, j = m - 1, k = dp[n][m] - 1;",
			"    while(k >= 0) {",
			"        if(s[i] == t[j]) {",
			"            sub[k] = s[i];",
			"            i--, j--, k--;",
			"        } else if(dp[i + 1][j + 1] == dp[i][j + 1]) {",
			"            i--;",
			"        } else {",
			"            j--;",
			"        }",
			"    }",
			"    return sub;",
			"}"
		],
		"description": "Longest Common Subsequence（最長共通部分列）"
	},
	"lis": {
		"scope": "cpp",
		"prefix": "lis",
		"body": [
			"// 最長増加部分列 (LIS: Longest Increasing Subsequence) の長さを求める．O(N*logN).",
			"template <typename Type, class Compare = std::function<bool(const Type &, const Type &)> >",
			"std::vector<int> lis(const std::vector<Type> &v, Compare comp = [](const Type &a, const Type &b) -> bool { return a < b; }) {",
			"    const int n = v.size();",
			"    std::vector<int> res(n, 0);  // res[i]:=(v[i]を最後の要素とする最長増加部分列の長さ).",
			"    std::vector<Type> dp;        // dp[k]:=(長さkの増加部分列のうち，その最後の要素の最小値).",
			"    for(int i = 0; i < n; ++i) {",
			"        auto itr = std::lower_bound(dp.begin(), dp.end(), v[i], comp);",
			"        res[i] = itr - dp.begin() + 1;",
			"        if(itr == dp.end()) dp.push_back(v[i]);",
			"        else *itr = v[i];",
			"    }",
			"    return res;",
			"}",
			"",
			"// 最長増加部分列 (LIS: Longest Increasing Subsequence) の長さを求める．O(N*logN).",
			"template <typename Type, class Compare = std::function<bool(const Type &, const Type &)> >",
			"std::vector<int> lis2(const std::vector<Type> &v, Compare comp = [](const Type &a, const Type &b) -> bool { return a < b; }) {",
			"    const int n = v.size();",
			"    std::vector<int> res(n + 1, 0);  // res[i]:=(v[:i]における最長増加部分列の長さ).",
			"    std::vector<Type> dp;            // dp[k]:=(長さkの増加部分列のうち，その最後の要素の最小値).",
			"    for(int i = 0; i < n; ++i) {",
			"        auto itr = std::lower_bound(dp.begin(), dp.end(), v[i], comp);",
			"        if(itr == dp.end()) dp.push_back(v[i]);",
			"        else *itr = v[i];",
			"        res[i + 1] = dp.size();",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Longest Increasing Subsequence（最長増加部分列）"
	},
	"mod_inv": {
		"scope": "cpp",
		"prefix": "mod_inv",
		"body": [
			"// モジュラ逆数（乗法逆元）．",
			"// a^-1 mod m を求める．解が存在する必要十分条件は，aとmが互いに素であること．O(log a).",
			"constexpr long long mod_inv(long long a, int mod) {",
			"    assert(mod >= 1);",
			"    long long b = mod, u = 1, v = 0;",
			"    while(b != 0) {",
			"        long long t = a / b;",
			"        a -= b * t, u -= v * t;",
			"        std::swap(a, b), std::swap(u, v);",
			"    }",
			"    if(u < 0) u += mod;",
			"    return u;",
			"}"
		],
		"description": "モジュラ逆数（乗法逆元）"
	},
	"mod_pow": {
		"scope": "cpp",
		"prefix": "mod_pow",
		"body": [
			"// 繰り返し二乗法（mod付き）．O(logK).",
			"constexpr long long mod_pow(long long n, long long k, int mod) {",
			"    assert(k >= 0);",
			"    assert(mod >= 1);",
			"    long long res = 1;",
			"    n %= mod;",
			"    while(k > 0) {",
			"        if(k & 1LL) res = res * n % mod;",
			"        n = n * n % mod;",
			"        k >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "繰り返し二乗法（mod付き）"
	},
	"nPk, nCk, nHk": {
		"scope": "cpp",
		"prefix": "nPk, nCk, nHk",
		"body": [
			"// 順列．O(K).",
			"constexpr long long nPk(long long n, long long k) {",
			"    assert(n >= 0);",
			"    assert(k >= 0);",
			"    if(n < k) return 0;",
			"    long long res = 1;",
			"    for(long long i = 0; i < k; ++i) res *= (n - i);",
			"    return res;",
			"}",
			"",
			"// 順列（mod付き）．O(K).",
			"constexpr long long nPk(long long n, long long k, int mod) {",
			"    assert(n >= 0);",
			"    assert(k >= 0);",
			"    assert(mod >= 1);",
			"    if(n < k) return 0;",
			"    n %= mod;",
			"    long long res = 1 % mod;",
			"    for(long long i = 0; i < k; ++i) {",
			"        long long tmp = n - i;",
			"        if(tmp < 0) tmp += mod;",
			"        res = res * tmp % mod;",
			"    }",
			"    return res;",
			"}",
			"",
			"// 組合せ．O(min(K,N-K)).",
			"constexpr long long nCk(long long n, long long k) {",
			"    assert(n >= 0);",
			"    assert(k >= 0);",
			"    if(n < k) return 0;",
			"    k = std::min(k, n - k);",
			"    long long res = 1;",
			"    for(long long i = 0; i < k; ++i) res = res * (n - i) / (i + 1);",
			"    return res;",
			"}",
			"",
			"// 組合せ（mod付き）．",
			"constexpr long long nCk(long long n, long long k, int mod) {",
			"    assert(n >= 0);",
			"    assert(k >= 0);",
			"    assert(mod >= 1);",
			"    if(n < k) return 0;",
			"    k = std::min(k, n - k);",
			"    return nPk(n, k, mod) * mod_inv(nPk(k, k, mod), mod) % mod;",
			"}",
			"",
			"// 重複組合せ．O(min(N-1,K)).",
			"constexpr long long nHk(long long n, long long k) {",
			"    assert(n >= 0);",
			"    assert(k >= 0);",
			"    if(k == 0) return 1;",
			"    if(n == 0) return 0;",
			"    return nCk(k + n - 1, k);",
			"}",
			"",
			"// 重複組合せ（mod付き）．",
			"constexpr long long nHk(long long n, long long k, int mod) {",
			"    assert(n >= 0);",
			"    assert(k >= 0);",
			"    assert(mod >= 1);",
			"    if(k == 0) return 1 % mod;",
			"    if(n == 0) return 0;",
			"    return nCk(k + n - 1, k, mod);",
			"}"
		],
		"description": "順列，組合せ，重複組合せ"
	},
	"nth_root": {
		"scope": "cpp",
		"prefix": "nth_root",
		"body": [
			"// 累乗根（ニュートン法）．xのn乗根を求める．",
			"constexpr double nth_root(double x, long long n, double eps = 1e-10) {",
			"    assert(x >= 0.0);",
			"    assert(n >= 1);",
			"    double res = 1.0;",
			"    while(true) {",
			"        double tmp = (x / pow(res, n - 1) + (n - 1) * res) / n;",
			"        if(std::abs(tmp - res) < eps) break;",
			"        res = tmp;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "累乗根（ニュートン法）"
	},
	"popcount": {
		"prefix": "popcount",
		"body": [
			"constexpr int popcount32(uint32_t bit) {",
			"    bit -= (bit >> 1) & 0x5555'5555U;",
			"    bit = (bit & 0x3333'3333U) + ((bit >> 2) & 0x3333'3333U);",
			"    bit = (bit + (bit >> 4)) & 0x0f0f'0f0fU;",
			"    bit += bit >> 8;",
			"    bit += bit >> 16;",
			"    return bit & 0x0000'003fU;",
			"}",
			"",
			"constexpr int popcount64(uint64_t bit) {",
			"    bit -= (bit >> 1) & 0x5555'5555'5555'5555ULL;",
			"    bit = (bit & 0x3333'3333'3333'3333ULL) + ((bit >> 2) & 0x3333'3333'3333'3333ULL);",
			"    bit = (bit + (bit >> 4)) & 0x0f0f'0f0f'0f0f'0f0fULL;",
			"    bit += bit >> 8;",
			"    bit += bit >> 16;",
			"    bit += bit >> 32;",
			"    return bit & 0x0000'0000'0000'007fULL;",
			"}"
		],
		"description": "Population Count (popcount)"
	},
	"prime_factorize": {
		"scope": "cpp",
		"prefix": "prime_factorize",
		"body": [
			"// 素因数分解．O(√N).",
			"template <typename Type>",
			"std::map<Type, int> prime_factorize(Type n) {",
			"    assert(n >= 0);",
			"    std::map<Type, int> res;  // res[p]:=(自然数nに含まれる素因数pの個数).",
			"    for(; n % 2 == 0; n /= 2) res[2]++;",
			"    for(Type p = 3; p * p <= n; p += 2) {",
			"        for(; n % p == 0; n /= p) res[p]++;",
			"    }",
			"    if(n > 1) res[n] = 1;",
			"    return res;",
			"}"
		],
		"description": "素因数分解"
	},
	"z_algorithm": {
		"scope": "cpp",
		"prefix": "z_algorithm",
		"body": [
			"// 最長共通接頭辞 (LCP: Longest Common Prefix) の長さを求める．",
			"// 引数はSTLのシーケンスコンテナであること．O(|S|).",
			"template <class Sequence>",
			"std::vector<int> z_algorithm(const Sequence &s) {",
			"    const int n = s.size();",
			"    std::vector<int> z(n);  // z[i]:=(sとs[i:]のLCPの長さ).",
			"    z[0] = n;",
			"    int i = 1, j = 0;",
			"    while(i < n) {",
			"        while(i + j < n and s[j] == s[i + j]) j++;",
			"        z[i] = j;",
			"        if(j == 0) {",
			"            i++;",
			"            continue;",
			"        }",
			"        int k = 1;",
			"        while(i + k < n and k + z[k] < j) {",
			"            z[i + k] = z[k];",
			"            k++;",
			"        }",
			"        i += k, j -= k;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "Z algorithm（最長共通接頭辞）"
	},
	"namespace algebra": {
		"scope": "cpp",
		"prefix": "namespace algebra",
		"body": [
			"namespace algebra {",
			"",
			"template <typename S>",
			"class Set {",
			"public:",
			"    using value_type = S;",
			"",
			"protected:",
			"    value_type val;",
			"",
			"public:",
			"    constexpr Set() : val() {}",
			"    constexpr Set(const value_type &val) : val(val) {}",
			"    constexpr Set(value_type &&val) : val(std::move(val)) {}",
			"",
			"    friend constexpr bool operator==(const Set &lhs, const Set &rhs) { return lhs.val == rhs.val; }",
			"    friend std::istream &operator>>(std::istream &is, Set &rhs) { return is >> rhs.val; }",
			"    friend std::ostream &operator<<(std::ostream &os, const Set &rhs) { return os << rhs.val; }",
			"",
			"    constexpr value_type value() const { return val; }",
			"};",
			"",
			"template <typename S, auto op>",
			"class Semigroup : public Set<S> {",
			"    static_assert(std::is_invocable_r<S, decltype(op), S, S>::value);",
			"",
			"    using base_type = Set<S>;",
			"",
			"public:",
			"    using value_type = typename base_type::value_type;",
			"",
			"    constexpr Semigroup() : base_type() {}",
			"    constexpr Semigroup(const value_type &val) : base_type(val) {}",
			"    constexpr Semigroup(value_type &&val) : base_type(std::move(val)) {}",
			"",
			"    friend constexpr Semigroup operator*(const Semigroup &lhs, const Semigroup &rhs) { return Semigroup(op(lhs.val, rhs.val)); }",
			"",
			"    static constexpr auto get_op() { return op; }",
			"};",
			"",
			"template <typename S, auto op, auto e>",
			"class Monoid : public Semigroup<S, op> {",
			"    static_assert(std::is_invocable_r<S, decltype(e)>::value);",
			"",
			"    using base_type = Semigroup<S, op>;",
			"",
			"public:",
			"    using value_type = typename base_type::value_type;",
			"",
			"    constexpr Monoid() : base_type() {}",
			"    constexpr Monoid(const value_type &val) : base_type(val) {}",
			"    constexpr Monoid(value_type &&val) : base_type(std::move(val)) {}",
			"",
			"    friend constexpr Monoid operator*(const Monoid &lhs, const Monoid &rhs) { return Monoid(op(lhs.val, rhs.val)); }",
			"",
			"    static constexpr auto get_e() { return e; }",
			"    static constexpr Monoid one() { return Monoid(e()); }  // return identity element.",
			"};",
			"",
			"template <typename S, auto op, auto e, auto inverse>",
			"class Group : public Monoid<S, op, e> {",
			"    static_assert(std::is_invocable_r<S, decltype(inverse), S>::value);",
			"",
			"    using base_type = Monoid<S, op, e>;",
			"",
			"public:",
			"    using value_type = typename base_type::value_type;",
			"",
			"    constexpr Group() : base_type() {}",
			"    constexpr Group(const value_type &val) : base_type(val) {}",
			"    constexpr Group(value_type &&val) : base_type(std::move(val)) {}",
			"",
			"    friend constexpr Group operator*(const Group &lhs, const Group &rhs) { return Group(op(lhs.val, rhs.val)); }",
			"",
			"    static constexpr auto get_inverse() { return inverse; }",
			"    static constexpr Group one() { return Group(e()); }                // return identity element.",
			"    constexpr Group inv() const { return Group(inverse(this->val)); }  // return inverse element.",
			"};",
			"",
			"template <typename F, auto compose, auto id, typename X, auto mapping>",
			"class OperatorMonoid : public Monoid<F, compose, id> {",
			"    static_assert(std::is_invocable_r<X, decltype(mapping), F, X>::value);",
			"",
			"    using base_type = Monoid<F, compose, id>;",
			"",
			"public:",
			"    using value_type = typename base_type::value_type;",
			"    using acted_value_type = X;",
			"",
			"    constexpr OperatorMonoid() : base_type() {}",
			"    constexpr OperatorMonoid(const value_type &val) : base_type(val) {}",
			"    constexpr OperatorMonoid(value_type &&val) : base_type(std::move(val)) {}",
			"",
			"    friend constexpr OperatorMonoid operator*(const OperatorMonoid &lhs, const OperatorMonoid &rhs) { return OperatorMonoid(compose(lhs.val, rhs.val)); }",
			"",
			"    static constexpr auto get_mapping() { return mapping; }",
			"    static constexpr OperatorMonoid one() { return OperatorMonoid(id()); }  // return identity mapping.",
			"    constexpr acted_value_type act(const acted_value_type &x) const { return mapping(this->val, x); }",
			"    template <class S>",
			"    constexpr S act(const S &x) const {",
			"        static_assert(std::is_base_of<Set<acted_value_type>, S>::value);",
			"        return S(mapping(this->val, x.value()));",
			"    }",
			"};",
			"",
			"namespace element {",
			"",
			"template <typename S>",
			"constexpr auto zero = []() -> S { return S(); };",
			"",
			"template <typename S>",
			"constexpr auto one = []() -> S { return 1; };",
			"",
			"template <typename S>",
			"constexpr auto min = []() -> S { return std::numeric_limits<S>::min(); };",
			"",
			"template <typename S>",
			"constexpr auto max = []() -> S { return std::numeric_limits<S>::max(); };",
			"",
			"template <typename S>",
			"constexpr auto one_below_max = []() -> S { return std::numeric_limits<S>::max() - 1; };",
			"",
			"template <typename S>",
			"constexpr auto lowest = []() -> S { return std::numeric_limits<S>::lowest(); };",
			"",
			"template <typename S>",
			"constexpr auto one_above_lowest = []() -> S { return std::numeric_limits<S>::lowest() + 1; };",
			"",
			"}  // namespace element",
			"",
			"namespace uoperator {",
			"",
			"template <typename S>",
			"constexpr auto identity = [](const S &val) -> S { return val; };",
			"",
			"template <typename S>",
			"constexpr auto negate = [](const S &val) -> S { return -val; };",
			"",
			"}  // namespace uoperator",
			"",
			"namespace boperator {",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto plus = [](const T &lhs, const S &rhs) -> S { return lhs + rhs; };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto mul = [](const T &lhs, const S &rhs) -> S { return lhs * rhs; };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto bit_and = [](const T &lhs, const S &rhs) -> S { return lhs & rhs; };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto bit_or = [](const T &lhs, const S &rhs) -> S { return lhs | rhs; };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto bit_xor = [](const T &lhs, const S &rhs) -> S { return lhs ^ rhs; };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto min = [](const T &lhs, const S &rhs) -> S { return std::min<S>(lhs, rhs); };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto max = [](const T &lhs, const S &rhs) -> S { return std::max<S>(lhs, rhs); };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto gcd = [](const T &lhs, const S &rhs) -> S { return std::gcd(lhs, rhs); };",
			"",
			"template <typename T, typename S = T>",
			"constexpr auto lcm = [](const T &lhs, const S &rhs) -> S { return std::lcm(lhs, rhs); };",
			"",
			"template <typename F, auto id, typename X = F>",
			"constexpr auto assign_if_not_id = [](const F &lhs, const X &rhs) -> X {",
			"    static_assert(std::is_invocable_r<F, decltype(id)>::value);",
			"    return (lhs == id() ? rhs : lhs);",
			"};",
			"",
			"}  // namespace boperator",
			"",
			"namespace monoid {",
			"",
			"template <typename S>",
			"using minimum = Monoid<S, boperator::min<S>, element::max<S>>;",
			"",
			"template <typename S>",
			"using minimum_safe = Monoid<S, boperator::min<S>, element::one_below_max<S>>;",
			"",
			"template <typename S>",
			"using maximum = Monoid<S, boperator::max<S>, element::lowest<S>>;",
			"",
			"template <typename S>",
			"using maximum_safe = Monoid<S, boperator::max<S>, element::one_above_lowest<S>>;",
			"",
			"template <typename S>",
			"using addition = Monoid<S, boperator::plus<S>, element::zero<S>>;",
			"",
			"template <typename S>",
			"using multiplication = Monoid<S, boperator::mul<S>, element::one<S>>;",
			"",
			"template <typename S>",
			"using bit_xor = Monoid<S, boperator::bit_xor<S>, element::zero<S>>;",
			"",
			"}  // namespace monoid",
			"",
			"namespace group {",
			"",
			"template <typename S>",
			"using addition = Group<S, boperator::plus<S>, element::zero<S>, uoperator::negate<S>>;",
			"",
			"template <typename S>",
			"using bit_xor = Group<S, boperator::bit_xor<S>, element::zero<S>, uoperator::identity<S>>;",
			"",
			"}  // namespace group",
			"",
			"namespace operator_monoid {",
			"",
			"template <typename F, typename X = F>",
			"using assign_for_minimum = OperatorMonoid<",
			"    F, boperator::assign_if_not_id<F, element::max<F>>, element::max<F>,",
			"    X, boperator::assign_if_not_id<F, element::max<F>, X>>;",
			"",
			"template <typename F, typename X = F>",
			"using assign_for_maximum = OperatorMonoid<",
			"    F, boperator::assign_if_not_id<F, element::lowest<F>>, element::lowest<F>,",
			"    X, boperator::assign_if_not_id<F, element::lowest<F>, X>>;",
			"",
			"template <typename F, typename X = F>",
			"using addition = OperatorMonoid<F, boperator::plus<F>, element::zero<F>, X, boperator::plus<F, X>>;",
			"",
			"}  // namespace operator_monoid",
			"",
			"}  // namespace algebra"
		],
		"description": ""
	},
	"namespace binary_indexed_tree": {
		"scope": "cpp",
		"prefix": "namespace binary_indexed_tree",
		"body": [
			"namespace binary_indexed_tree {",
			"",
			"template <class AbelianGroup>",
			"class BIT {",
			"public:",
			"    using group_type = AbelianGroup;",
			"    using value_type = group_type::value_type;",
			"",
			"private:",
			"    std::vector<group_type> m_tree;",
			"",
			"    static constexpr int lsb(int bit) { return bit & -bit; }",
			"    group_type sum_internal(int r) const {",
			"        group_type &&res = group_type::one();",
			"        for(; r >= 1; r -= lsb(r)) res = res * m_tree[r - 1];",
			"        return res;",
			"    }",
			"    void build() {",
			"        for(int i = 1, end = size(); i < end; ++i) {",
			"            int j = i + lsb(i);",
			"            if(j <= end) m_tree[j - 1] = m_tree[j - 1] * m_tree[i - 1];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT() : BIT(0) {};",
			"    explicit BIT(int n) : m_tree(n, group_type::one()) {",
			"        assert(n >= 0);",
			"    }",
			"    explicit BIT(int n, const value_type &a) : BIT(n, group_type(a)) {}",
			"    explicit BIT(int n, const group_type &a) : m_tree(n, a) {",
			"        assert(n >= 0);",
			"        build();",
			"    }",
			"    template <std::input_iterator InputIter>",
			"    explicit BIT(InputIter first, InputIter last) : m_tree(first, last) {",
			"        build();",
			"    }",
			"    template <typename T>",
			"    explicit BIT(std::initializer_list<T> il) : BIT(il.begin(), il.end()) {}",
			"    explicit BIT(const std::vector<group_type> &v) : m_tree(v) {",
			"        build();",
			"    }",
			"    explicit BIT(std::vector<group_type> &&v) : m_tree(std::move(v)) {",
			"        build();",
			"    }",
			"",
			"    // 要素数を取得する．",
			"    int size() const { return m_tree.size(); }",
			"    // k番目の要素にaを加算する．O(log N).",
			"    void add(int k, const value_type &a) {",
			"        add(k, group_type(a));",
			"    }",
			"    void add(int k, const group_type &a) {",
			"        assert(0 <= k and k < size());",
			"        for(int i = k + 1, end = size(); i <= end; i += lsb(i)) m_tree[i - 1] = m_tree[i - 1] * a;",
			"    }",
			"    // 区間[0,r)の要素の総和を求める．O(log N).",
			"    value_type sum(int r) const {",
			"        assert(0 <= r and r <= size());",
			"        return sum_internal(r).value();",
			"    }",
			"    // 区間[l,r)の要素の総和を求める．O(log N).",
			"    value_type sum(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        return (sum_internal(r) * sum_internal(l).inv()).value();",
			"    }",
			"    // pred(sum(r))==true となる区間の最右位値rを二分探索する．",
			"    // ただし，区間[0,n)の要素はpred(S)によって区分化されていること．また，pred(e)==true であること．O(log N).",
			"    template <bool (*pred)(value_type)>",
			"    int most_right() const {",
			"        return most_right([](const value_type &x) -> bool { return pred(x); });",
			"    }",
			"    template <typename Pred>",
			"    int most_right(Pred pred) const {",
			"        static_assert(std::is_invocable_r<bool, Pred, value_type>::value);",
			"        assert(pred(group_type::one().value()));",
			"        const int sz = size();",
			"        int r = 0;",
			"        group_type &&val = group_type::one();",
			"        for(int i = 1; i <= sz and pred(m_tree[i - 1].value()); i <<= 1) r = i, val = m_tree[i - 1];",
			"        for(int len = r >> 1; len > 0; len >>= 1) {",
			"            if(r + len <= sz and pred((val * m_tree[r + len - 1]).value())) {",
			"                r += len;",
			"                val = val * m_tree[r - 1];",
			"            }",
			"        }",
			"        return r;",
			"    }",
			"    void reset() {",
			"        std::fill(m_tree.begin(), m_tree.end(), group_type::one());",
			"    }",
			"};",
			"",
			"template <typename S>",
			"using range_sum_binary_indexed_tree = BIT<algebra::group::addition<S>>;",
			"",
			"template <typename S>",
			"using range_xor_binary_indexed_tree = BIT<algebra::group::bit_xor<S>>;",
			"",
			"}  // namespace binary_indexed_tree"
		],
		"description": ""
	},
	"namespace dynamic_segment_tree": {
		"scope": "cpp",
		"prefix": "namespace dynamic_segment_tree",
		"body": [
			"namespace dynamic_segment_tree {",
			"",
			"template <class Monoid>",
			"class DynamicSegmentTree {",
			"public:",
			"    using monoid_type = Monoid;",
			"    using value_type = monoid_type::value_type;",
			"    using size_type = std::size_t;",
			"",
			"private:",
			"    struct Node;",
			"    using node_pointer = std::unique_ptr<Node>;",
			"",
			"    struct Node {",
			"        size_type index;",
			"        monoid_type value;",
			"        monoid_type product;",
			"        node_pointer left, right;",
			"",
			"        explicit Node(size_type index, const monoid_type &value) : index(index), value(value), product(value), left(nullptr), right(nullptr) {}",
			"    };",
			"",
			"    size_type m_sz;       // m_sz:=(要素数).",
			"    node_pointer m_root;  // m_root:=(根のポインタ).",
			"",
			"    void update(const node_pointer &p) const {",
			"        assert(p);",
			"        const monoid_type &lhs = (p->left ? p->left->product : monoid_type::one());",
			"        const monoid_type &rhs = (p->right ? p->right->product : monoid_type::one());",
			"        p->product = lhs * p->value * rhs;",
			"    }",
			"    void set(node_pointer &p, size_type k, monoid_type a, size_type l, size_type r) {",
			"        if(!p) {",
			"            p = std::make_unique<Node>(k, a);",
			"            return;",
			"        }",
			"        if(p->index == k) {",
			"            p->value = a;",
			"            update(p);",
			"            return;",
			"        }",
			"        size_type mid = l + (r - l) / 2;",
			"        if(k < mid) {",
			"            if(p->index < k) std::swap(k, p->index), std::swap(a, p->value);",
			"            set(p->left, k, a, l, mid);",
			"        } else {",
			"            if(k < p->index) std::swap(k, p->index), std::swap(a, p->value);",
			"            set(p->right, k, a, mid, r);",
			"        }",
			"        update(p);",
			"    }",
			"    monoid_type prod(const node_pointer &p, size_type k, size_type l, size_type r) const {",
			"        if(!p) return monoid_type::one();",
			"        if(p->index == k) return p->value;",
			"        size_type mid = l + (r - l) / 2;",
			"        return (k < mid ? prod(p->left, k, l, mid) : prod(p->right, k, mid, r));",
			"    }",
			"    monoid_type prod(const node_pointer &p, size_type l, size_type r, size_type ll, size_type rr) const {",
			"        if(!p or r <= ll or rr <= l) return monoid_type::one();",
			"        if(l <= ll and rr <= r) return p->product;",
			"        size_type mid = ll + (rr - ll) / 2;",
			"        return prod(p->left, l, r, ll, mid) * (l <= p->index and p->index < r ? p->value : monoid_type::one()) * prod(p->right, l, r, mid, rr);",
			"    }",
			"    template <typename Pred>",
			"    size_type most_right(const node_pointer &p, size_type l, Pred pred, size_type ll, size_type rr, monoid_type &product) const {",
			"        if(!p or rr <= l) return rr;",
			"        if(l <= ll and pred((product * p->product).value())) {",
			"            product = product * p->product;",
			"            return rr;",
			"        }",
			"        size_type mid = ll + (rr - ll) / 2;",
			"        size_type itr = most_right(p->left, l, pred, ll, mid, product);",
			"        if(itr < mid) return itr;",
			"        if(l <= p->index) {",
			"            product = product * p->value;",
			"            if(!pred(product.value())) return p->index;",
			"        }",
			"        return most_right(p->right, l, pred, mid, rr, product);",
			"    }",
			"    template <typename Pred>",
			"    size_type most_left(const node_pointer &p, size_type r, Pred pred, size_type ll, size_type rr, monoid_type &product) const {",
			"        if(!p or r <= ll) return ll;",
			"        if(rr <= r and pred(p->product * product).value()) {",
			"            product = p->product * product;",
			"            return ll;",
			"        }",
			"        size_type mid = ll + (rr - ll) / 2;",
			"        size_type itr = most_left(p->right, r, pred, mid, rr, product);",
			"        if(mid < itr) return itr;",
			"        if(p->index < r) {",
			"            product = p->value * product;",
			"            if(!pred(product.value())) return p->index + 1;",
			"        }",
			"        return most_left(p->left, r, pred, ll, mid, product);",
			"    }",
			"    void reset(node_pointer &p, size_type l, size_type r, size_type ll, size_type rr) {",
			"        if(!p or r <= ll or rr <= l) return;",
			"        if(l <= ll and rr <= r) {",
			"            p.reset();",
			"            return;",
			"        }",
			"        size_type mid = ll + (rr - ll) / 2;",
			"        reset(p->left, l, r, ll, mid);",
			"        reset(p->right, l, r, mid, rr);",
			"        if(l <= p->index and p->index < r) p->value = monoid_type::one();",
			"        update(p);",
			"    }",
			"    void print(std::ostream &os, const node_pointer &p, bool &first) const {",
			"        if(!p) return;",
			"        print(os, p->left, first);",
			"        os << (first ? \"{\" : \" {\") << p->index << \", \" << p->value << \"}\";",
			"        first = false;",
			"        print(os, p->right, first);",
			"    }",
			"",
			"public:",
			"    DynamicSegmentTree() : DynamicSegmentTree(0) {};",
			"    explicit DynamicSegmentTree(size_type n) : m_sz(n), m_root(nullptr) {}",
			"",
			"    // 要素数を取得する．",
			"    size_type size() const { return m_sz; }",
			"    // k番目の要素をaに置き換える．O(log N).",
			"    void set(size_type k, const value_type &a) {",
			"        set(k, monoid_type(a));",
			"    }",
			"    void set(size_type k, const monoid_type &a) {",
			"        assert(k < size());",
			"        set(m_root, k, a, 0, size());",
			"    }",
			"    // k番目の要素を取得する．O(log N).",
			"    value_type prod(size_type k) const {",
			"        assert(k < size());",
			"        return prod(m_root, k, 0, size()).value();",
			"    }",
			"    // 区間[l,r)の要素の総積を求める．O(log N).",
			"    value_type prod(size_type l, size_type r) const {",
			"        assert(l <= r and r <= size());",
			"        return prod(m_root, l, r, 0, size()).value();",
			"    }",
			"    // 区間全体の要素の総積を取得する．O(1).",
			"    value_type prod_all() const { return (m_root ? m_root->product : monoid_type::one()).value(); }",
			"    // pred(prod(l,r))==true となる区間の最右位値rを二分探索する．",
			"    // ただし，区間[l,n)の要素はpred(S)によって区分化されていること．また，pred(e)==true であること．O(log N).",
			"    template <bool (*pred)(value_type)>",
			"    size_type most_right(size_type l) const {",
			"        return most_right(l, [](const value_type &x) -> bool { return pred(x); });",
			"    }",
			"    template <typename Pred>",
			"    size_type most_right(size_type l, Pred pred) const {",
			"        static_assert(std::is_invocable_r<bool, Pred, value_type>::value);",
			"        assert(l <= size());",
			"        assert(pred(monoid_type::one().value()));",
			"        monoid_type &&product = monoid_type::one();",
			"        return most_right(m_root, l, pred, 0, size(), product);",
			"    }",
			"    // pred(prod(l,r))==true となる区間の最左位値lを二分探索する．",
			"    // ただし，区間[0,r)の要素はpred(S)によって区分化されていること．また，pred(e)==true であること．O(log N).",
			"    template <bool (*pred)(value_type)>",
			"    size_type most_left(int r) const {",
			"        return most_left(r, [](const value_type &x) -> bool { return pred(x); });",
			"    }",
			"    template <typename Pred>",
			"    size_type most_left(size_type r, Pred pred) const {",
			"        static_assert(std::is_invocable_r<bool, Pred, value_type>::value);",
			"        assert(r <= size());",
			"        assert(pred(monoid_type::one().value()));",
			"        value_type &&product = monoid_type::one();",
			"        return most_left(m_root, r, pred, 0, size(), product);",
			"    }",
			"    void reset(size_type l, size_type r) {",
			"        assert(l <= r and r <= size());",
			"        reset(m_root, l, r, 0, size());",
			"    }",
			"    void reset() {",
			"        m_root.reset();",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const DynamicSegmentTree &rhs) {",
			"        os << \"[\";",
			"        bool first = true;",
			"        rhs.print(os, rhs.m_root, first);",
			"        return os << \"]\";",
			"    }",
			"};",
			"",
			"template <typename S>",
			"using range_minimum_dynamic_segment_tree = DynamicSegmentTree<algebra::monoid::minimum<S>>;",
			"",
			"template <typename S>",
			"using range_maximum_dynamic_segment_tree = DynamicSegmentTree<algebra::monoid::maximum<S>>;",
			"",
			"template <typename S>",
			"using range_sum_dynamic_segment_tree = DynamicSegmentTree<algebra::monoid::addition<S>>;",
			"",
			"}  // namespace dynamic_segment_tree"
		],
		"description": ""
	},
	"namespace fft": {
		"scope": "cpp",
		"prefix": "namespace fft",
		"body": [
			"namespace fft {",
			"",
			"using D = double;",
			"",
			"const D PI = std::acos(-1.0);",
			"",
			"// Fast Fourier Transform（高速フーリエ変換）.",
			"// 引数の数列の長さは2のべき乗であること．O(N*logN).",
			"void transform(std::vector<std::complex<D> > &a, bool inv = false) {",
			"    const int n = a.size();",
			"    if(n == 0) return;",
			"    int lb = 0;  // lb:=log2(n).",
			"    while(1 << lb < n) lb++;",
			"    assert(n == 1 << lb);",
			"    for(int i = 0; i < n; ++i) {",
			"        int j = 0;",
			"        for(int k = 0; k < lb; ++k) j |= (i >> k & 1) << (lb - 1 - k);",
			"        if(i < j) std::swap(a[i], a[j]);",
			"    }",
			"    for(int b = 1; b < n; b <<= 1) {",
			"        D ang = PI / b;",
			"        if(inv) ang = -ang;",
			"        for(int i = 0; i < b; ++i) {",
			"            std::complex<D> &&w = std::polar<D>(1.0, ang * i);",
			"            for(int j = 0; j < n; j += b << 1) {",
			"                std::complex<D> &&tmp = a[i + j + b] * w;",
			"                a[i + j + b] = a[i + j] - tmp;",
			"                a[i + j] += tmp;",
			"            }",
			"        }",
			"    }",
			"    if(inv) {",
			"        for(int i = 0; i < n; ++i) a[i] /= n;",
			"    }",
			"}",
			"",
			"// 畳み込み．",
			"// 数列a[], b[]に対して，c[i]=sum_{k=0}^{i} a[k]*b[i-k] となる数列c[]を求める．O(N^2).",
			"template <typename Type>",
			"std::vector<Type> convolve_naive(const std::vector<Type> &a, const std::vector<Type> &b) {",
			"    const int n = a.size(), m = b.size();",
			"    if(n == 0 or m == 0) return std::vector<Type>();",
			"    std::vector<Type> res(n + m - 1, 0);",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < m; ++j) res[i + j] += a[i] * b[j];",
			"    }",
			"    return res;",
			"}",
			"",
			"// 畳み込み．",
			"// 数列a[], b[]に対して，c[i]=sum_{k=0}^{i} a[k]*b[i-k] となる数列c[]を求める．O(N*logN).",
			"template <typename Type, typename std::enable_if_t<std::is_integral_v<Type>, bool> = false>",
			"std::vector<Type> convolve(const std::vector<Type> &a, const std::vector<Type> &b) {",
			"    if(a.size() == 0 or b.size() == 0) return std::vector<Type>();",
			"    const int n = a.size() + b.size() - 1;",
			"    int m = 1;",
			"    while(m < n) m <<= 1;",
			"    std::vector<std::complex<D> > na(m, 0.0), nb(m, 0.0);",
			"    std::copy(a.begin(), a.end(), na.begin());",
			"    std::copy(b.begin(), b.end(), nb.begin());",
			"    transform(na), transform(nb);",
			"    for(int i = 0; i < m; ++i) na[i] *= nb[i];",
			"    transform(na, true);",
			"    std::vector<Type> res(n);",
			"    for(int i = 0; i < n; ++i) res[i] = na[i].real() + (na[i].real() < 0.0 ? -0.5 : 0.5);",
			"    return res;",
			"}",
			"",
			"// 畳み込み．",
			"// 数列a[], b[]に対して，c[i]=sum_{k=0}^{i} a[k]*b[i-k] となる数列c[]を求める．O(N*logN).",
			"template <typename Type, typename std::enable_if_t<std::is_floating_point_v<Type>, bool> = false>",
			"std::vector<Type> convolve(const std::vector<Type> &a, const std::vector<Type> &b) {",
			"    if(a.size() == 0 or b.size() == 0) return std::vector<Type>();",
			"    const int n = a.size() + b.size() - 1;",
			"    int m = 1;",
			"    while(m < n) m <<= 1;",
			"    std::vector<std::complex<D> > na(m, 0.0), nb(m, 0.0);",
			"    std::copy(a.begin(), a.end(), na.begin());",
			"    std::copy(b.begin(), b.end(), nb.begin());",
			"    transform(na), transform(nb);",
			"    for(int i = 0; i < m; ++i) na[i] *= nb[i];",
			"    transform(na, true);",
			"    std::vector<Type> res(n);",
			"    for(int i = 0; i < n; ++i) res[i] = na[i].real();",
			"    return res;",
			"}",
			"",
			"}  // namespace fft"
		],
		"description": "Fast Fourier Transform（高速フーリエ変換）"
	},
	"namespace ntt": {
		"scope": "cpp",
		"prefix": "namespace ntt",
		"body": [
			"namespace ntt {",
			"",
			"constexpr int MOD = 998'244'353;     // 998'244'353 = 2^23 * 7 * 17 + 1.",
			"constexpr int MOD2 = 167'772'161;    // 167'772'161 = 2^25 * 5 + 1.",
			"constexpr int MOD3 = 469'762'049;    // 469'762'049 = 2^26 * 7 + 1.",
			"constexpr int MOD4 = 754'974'721;    // 754'974'721 = 2^24 * 3^2 * 5 + 1.",
			"constexpr int MOD5 = 1'107'296'257;  // 1'107'296'257 = 2^25 * 3 * 11 + 1.",
			"constexpr int MOD6 = 1'224'736'769;  // 1'224'736'769 = 2^24 * 73 + 1.",
			"constexpr int MOD7 = 1'711'276'033;  // 1'224'736'769 = 2^25 * 3 * 17 + 1.",
			"constexpr int MOD8 = 1'811'939'329;  // 1'224'736'769 = 2^26 * 3^3 + 1.",
			"",
			"// 素数判定．O(√N).",
			"template <typename Type>",
			"constexpr bool is_prime(Type n) {",
			"    assert(n >= 0);",
			"    if(n < 2) return false;",
			"    if(n == 2) return true;",
			"    if(n % 2 == 0) return false;",
			"    for(Type p = 3; p * p <= n; p += 2) {",
			"        if(n % p == 0) return false;",
			"    }",
			"    return true;",
			"}",
			"",
			"// 繰り返し二乗法（mod付き）．n^k (mod m) を求める．O(logK).",
			"constexpr int mod_pow(long long n, long long k, int m) {",
			"    assert(k >= 0);",
			"    assert(m >= 1);",
			"    long long res = 1;",
			"    n %= m;",
			"    while(k > 0) {",
			"        if(k & 1LL) res = res * n % m;",
			"        n = n * n % m;",
			"        k >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"// 素数pを法とする最小の原始根を求める．",
			"constexpr int primitive_root(int p) {",
			"    assert(p >= 2);",
			"    if(p == 2) return 1;",
			"    if(p == MOD) return 3;",
			"    if(p == MOD2) return 3;",
			"    if(p == MOD3) return 3;",
			"    if(p == MOD4) return 11;",
			"    if(p == MOD5) return 10;",
			"    if(p == MOD6) return 3;",
			"    if(p == MOD7) return 29;",
			"    if(p == MOD8) return 13;",
			"    assert(is_prime(p));",
			"    std::array<int, 20> divs({2});  // divs[]:=(p-1の素因数).",
			"    int cnt = 1;",
			"    int n = (p - 1) / 2;",
			"    while(n % 2 == 0) n /= 2;",
			"    for(int q = 3; q * q <= n; q += 2) {",
			"        if(n % q == 0) {",
			"            divs[cnt++] = q;",
			"            while(n % q == 0) n /= q;",
			"        }",
			"    }",
			"    if(n > 1) divs[cnt++] = n;",
			"    for(int g = 2;; ++g) {",
			"        bool ok = true;",
			"        for(int i = 0; i < cnt; ++i) {",
			"            if(mod_pow(g, (p - 1) / divs[i], p) == 1) {",
			"                ok = false;",
			"                break;",
			"            }",
			"        }",
			"        if(ok) return g;",
			"    }",
			"}",
			"",
			"// Number Theoretic Transform（数論変換）.",
			"// 引数の数列の長さは2のべき乗であること．O(N*logN).",
			"template <class mint, typename std::enable_if_t<is_modint_v<mint>, bool> = false>",
			"void transform(std::vector<mint> &a, bool inv = false) {",
			"    const int n = a.size();",
			"    if(n == 0) return;",
			"    assert((mint::modulus() - 1) % n == 0);",
			"    static bool first = true;",
			"    static std::array<mint, 30> ws, inv_ws;  // ws[k]:=(2^k乗根), inv_ws[k]:=(2^k乗根の逆元).",
			"    if(first) {",
			"        mint &&pr = primitive_root(mint::modulus());",
			"        int rank = 0;",
			"        while(!((mint::modulus() - 1) & 1 << rank)) rank++;",
			"        ws[rank] = pr.pow((mint::modulus() - 1) >> rank);",
			"        inv_ws[rank] = ws[rank].inv();",
			"        for(int k = rank - 1; k >= 0; --k) {",
			"            ws[k] = ws[k + 1] * ws[k + 1];",
			"            inv_ws[k] = inv_ws[k + 1] * inv_ws[k + 1];",
			"        }",
			"        first = false;",
			"    }",
			"    int lb = 0;  // lb:=log2(n).",
			"    while(1 << lb < n) lb++;",
			"    assert(n == 1 << lb);",
			"    for(int i = 0; i < n; ++i) {",
			"        int j = 0;",
			"        for(int k = 0; k < lb; ++k) j |= (i >> k & 1) << (lb - 1 - k);",
			"        if(i < j) std::swap(a[i], a[j]);",
			"    }",
			"    for(int b = 1, k = 1; b < n; b <<= 1, ++k) {",
			"        mint w = 1;",
			"        for(int i = 0; i < b; ++i) {",
			"            for(int j = 0; j < n; j += b << 1) {",
			"                mint &&tmp = a[i + j + b] * w;",
			"                a[i + j + b] = a[i + j] - tmp;",
			"                a[i + j] += tmp;",
			"            }",
			"            w *= (inv ? inv_ws[k] : ws[k]);",
			"        }",
			"    }",
			"    if(inv) {",
			"        mint &&tmp = mint(n).inv();",
			"        for(int i = 0; i < n; ++i) a[i] *= tmp;",
			"    }",
			"}",
			"",
			"// 畳み込み．",
			"// 数列a[], b[]に対して，c[i]=sum_{k=0}^{i} a[k]*b[i-k] となる数列c[]を求める．O(N^2).",
			"template <typename Type>",
			"std::vector<Type> convolve_naive(const std::vector<Type> &a, const std::vector<Type> &b) {",
			"    const int n = a.size(), m = b.size();",
			"    if(n == 0 or m == 0) return std::vector<Type>();",
			"    std::vector<Type> res(n + m - 1, 0);",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < m; ++j) res[i + j] += a[i] * b[j];",
			"    }",
			"    return res;",
			"}",
			"",
			"// 畳み込み．",
			"// 数列a[], b[]に対して，c[i]=sum_{k=0}^{i} a[k]*b[i-k] となる数列c[]を求める．O(N*logN).",
			"template <class mint, typename std::enable_if_t<is_modint_v<mint>, bool> = false>",
			"std::vector<mint> convolve(std::vector<mint> a, std::vector<mint> b) {",
			"    if(a.size() == 0 or b.size() == 0) return std::vector<mint>();",
			"    const int n = a.size() + b.size() - 1;",
			"    int m = 1;",
			"    while(m < n) m <<= 1;",
			"    a.resize(m, 0), b.resize(m, 0);",
			"    transform(a), transform(b);",
			"    for(int i = 0; i < m; ++i) a[i] *= b[i];",
			"    transform(a, true);",
			"    a.resize(n);",
			"    return a;",
			"}",
			"",
			"}  // namespace ntt"
		],
		"description": "Number Theoretic Transform（数論変換）"
	},
	"namespace segment_tree": {
		"scope": "cpp",
		"prefix": "namespace segment_tree",
		"body": [
			"namespace segment_tree {",
			"",
			"template <class Monoid>",
			"class SegmentTree {",
			"public:",
			"    using monoid_type = Monoid;",
			"    using value_type = monoid_type::value_type;",
			"",
			"private:",
			"    int m_sz;                         // m_sz:=(要素数).",
			"    int m_n;                          // m_n:=(完全二分木の葉数).",
			"    std::vector<monoid_type> m_tree;  // m_tree(2n)[]:=(完全二分木). 1-based index.",
			"",
			"    void update(int k) {",
			"        m_tree[k] = m_tree[k << 1] * m_tree[k << 1 | 1];",
			"    }",
			"    void build() {",
			"        for(int l = m_n >> 1, r = (m_n + m_sz - 1) >> 1; l >= 1; l >>= 1, r >>= 1) {",
			"            for(int i = r; i >= l; --i) update(i);",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    SegmentTree() : SegmentTree(0) {};",
			"    explicit SegmentTree(int n) : m_sz(n), m_n(1) {",
			"        assert(n >= 0);",
			"        while(m_n < m_sz) m_n <<= 1;",
			"        m_tree.assign(2 * m_n, monoid_type::one());",
			"    }",
			"    explicit SegmentTree(int n, const value_type &a) : SegmentTree(n, monoid_type(a)) {}",
			"    explicit SegmentTree(int n, const monoid_type &a) : SegmentTree(n) {",
			"        std::fill_n(m_tree.begin() + m_n, n, a);",
			"        build();",
			"    }",
			"    template <std::input_iterator InputIter>",
			"    explicit SegmentTree(InputIter first, InputIter last) : m_n(1), m_tree(first, last) {",
			"        m_sz = m_tree.size();",
			"        while(m_n < m_sz) m_n <<= 1;",
			"        m_tree.reserve(2 * m_n);",
			"        m_tree.insert(m_tree.begin(), m_n, monoid_type::one());",
			"        m_tree.resize(2 * m_n, monoid_type::one());",
			"        build();",
			"    }",
			"    template <typename T>",
			"    explicit SegmentTree(std::initializer_list<T> il) : SegmentTree(il.begin(), il.end()) {}",
			"",
			"    // 要素数を取得する．",
			"    int size() const { return m_sz; }",
			"    // k番目の要素をaに置き換える．O(log N).",
			"    void set(int k, const value_type &a) {",
			"        set(k, monoid_type(a));",
			"    }",
			"    void set(int k, const monoid_type &a) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        m_tree[k] = a;",
			"        while(k >>= 1) update(k);",
			"    }",
			"    // k番目の要素を取得する．O(1).",
			"    value_type prod(int k) const {",
			"        assert(0 <= k and k < size());",
			"        return m_tree[k + m_n].value();",
			"    }",
			"    // 区間[l,r)の要素の総積を求める．O(log N).",
			"    value_type prod(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        monoid_type &&val_l = monoid_type::one(), &&val_r = monoid_type::one();",
			"        for(l += m_n, r += m_n; l < r; l >>= 1, r >>= 1) {",
			"            if(l & 1) val_l = val_l * m_tree[l++];",
			"            if(r & 1) val_r = m_tree[--r] * val_r;",
			"        }",
			"        return (val_l * val_r).value();",
			"    }",
			"    // 区間全体の要素の総積を取得する．O(1).",
			"    value_type prod_all() const { return m_tree[1].value(); }",
			"    // pred(prod(l,r))==true となる区間の最右位値rを二分探索する．",
			"    // ただし，区間[l,n)の要素はpred(S)によって区分化されていること．また，pred(e)==true であること．O(log N).",
			"    template <bool (*pred)(value_type)>",
			"    int most_right(int l) const {",
			"        return most_right(l, [](const value_type &x) -> bool { return pred(x); });",
			"    }",
			"    template <typename Pred>",
			"    int most_right(int l, Pred pred) const {",
			"        static_assert(std::is_invocable_r<bool, Pred, value_type>::value);",
			"        assert(0 <= l and l <= size());",
			"        assert(pred(monoid_type::one().value()));",
			"        if(l == m_sz) return m_sz;",
			"        l += m_n;",
			"        monoid_type &&val = monoid_type::one();",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            monoid_type &&tmp = val * m_tree[l];",
			"            if(!pred(tmp.value())) {",
			"                while(l < m_n) {",
			"                    l <<= 1;",
			"                    tmp = val * m_tree[l];",
			"                    if(pred(tmp.value())) val = tmp, ++l;",
			"                }",
			"                return l - m_n;",
			"            }",
			"            val = tmp, ++l;",
			"        } while((l & -l) != l);",
			"        return m_sz;",
			"    }",
			"    // pred(prod(l,r))==true となる区間の最左位値lを二分探索する．",
			"    // ただし，区間[0,r)の要素はpred(S)によって区分化されていること．また，pred(e)==true であること．O(log N).",
			"    template <bool (*pred)(value_type)>",
			"    int most_left(int r) const {",
			"        return most_left(r, [](const value_type &x) -> bool { return pred(x); });",
			"    }",
			"    template <typename Pred>",
			"    int most_left(int r, Pred pred) const {",
			"        static_assert(std::is_invocable_r<bool, Pred, value_type>::value);",
			"        assert(0 <= r and r <= size());",
			"        assert(pred(monoid_type::one().value()));",
			"        if(r == 0) return 0;",
			"        r += m_n;",
			"        monoid_type &&val = monoid_type::one();",
			"        do {",
			"            --r;",
			"            while(r > 1 and (r & 1)) r >>= 1;",
			"            monoid_type &&tmp = m_tree[r] * val;",
			"            if(!pred(tmp.value())) {",
			"                while(r < m_n) {",
			"                    r = r << 1 | 1;",
			"                    tmp = m_tree[r] * val;",
			"                    if(pred(tmp.value())) val = tmp, --r;",
			"                }",
			"                return r + 1 - m_n;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);",
			"        return 0;",
			"    }",
			"    void reset() {",
			"        std::fill(m_tree.begin() + 1, m_tree.begin() + m_n + m_sz, monoid_type::one());",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const SegmentTree &rhs) {",
			"        os << \"[\\n\";",
			"        for(int l = 1, r = 2; r <= 2 * rhs.m_n; l <<= 1, r <<= 1) {",
			"            for(int i = l; i < r; ++i) os << (i == l ? \"  [\" : \" \") << rhs.m_tree[i].value();",
			"            os << \"]\\n\";",
			"        }",
			"        return os << \"]\";",
			"    }",
			"};",
			"",
			"template <typename S>",
			"using range_minimum_segment_tree = SegmentTree<algebra::monoid::minimum<S>>;",
			"",
			"template <typename S>",
			"using range_maximum_segment_tree = SegmentTree<algebra::monoid::maximum<S>>;",
			"",
			"template <typename S>",
			"using range_sum_segment_tree = SegmentTree<algebra::monoid::addition<S>>;",
			"",
			"}  // namespace segment_tree"
		],
		"description": ""
	},
	"namespace lazy_segment_tree": {
		"scope": "cpp",
		"prefix": "namespace lazy_segment_tree",
		"body": [
			"namespace lazy_segment_tree {",
			"",
			"template <class ActedMonoid, class OperatorMonoid>",
			"class LazySegmentTree {",
			"public:",
			"    using acted_monoid_type = ActedMonoid;",
			"    using operator_monoid_type = OperatorMonoid;",
			"    using acted_value_type = acted_monoid_type::value_type;",
			"    using operator_value_type = operator_monoid_type::value_type;",
			"",
			"private:",
			"    int m_sz;                                  // m_sz:=(要素数).",
			"    int m_n;                                   // m_n:=(完全二分木の葉数).",
			"    int m_depth;                               // m_depth:=(完全二分木の深さ).",
			"    std::vector<acted_monoid_type> m_tree;     // m_tree(2n)[]:=(完全二分木). 1-based index.",
			"    std::vector<operator_monoid_type> m_lazy;  // m_lazy(n)[k]:=(m_tree[k]の子 (m_tree[2k], m_tree[2k+1]) に対する遅延評価).",
			"",
			"    void apply_with_lazy(int k, const operator_monoid_type &f) {",
			"        m_tree[k] = f.act(m_tree[k]);",
			"        if(k < m_n) m_lazy[k] = f * m_lazy[k];",
			"    }",
			"    void push(int k) {",
			"        apply_with_lazy(k << 1, m_lazy[k]);",
			"        apply_with_lazy(k << 1 | 1, m_lazy[k]);",
			"        m_lazy[k] = operator_monoid_type::one();",
			"    }",
			"    void update(int k) {",
			"        m_tree[k] = m_tree[k << 1] * m_tree[k << 1 | 1];",
			"    }",
			"    void build() {",
			"        for(int i = 1; i <= m_depth; ++i) {",
			"            int l = m_n >> i, r = (m_n + m_sz - 1) >> i;",
			"            for(int j = r; j >= l; --j) update(j);",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    LazySegmentTree() : LazySegmentTree(0) {}",
			"    explicit LazySegmentTree(int n) : m_sz(n), m_n(1), m_depth(0) {",
			"        assert(n >= 0);",
			"        while(m_n < m_sz) m_n <<= 1, ++m_depth;",
			"        m_tree.assign(2 * m_n, acted_monoid_type::one());",
			"        m_lazy.assign(m_n, operator_monoid_type::one());",
			"    }",
			"    explicit LazySegmentTree(int n, const acted_value_type &a) : LazySegmentTree(n, acted_monoid_type(a)) {}",
			"    explicit LazySegmentTree(int n, const acted_monoid_type &a) : LazySegmentTree(n) {",
			"        std::fill_n(m_tree.begin() + m_n, n, a);",
			"        build();",
			"    }",
			"    template <std::input_iterator InputIter>",
			"    explicit LazySegmentTree(InputIter first, InputIter last) : m_n(1), m_depth(0), m_tree(first, last) {",
			"        m_sz = m_tree.size();",
			"        while(m_n < m_sz) m_n <<= 1, ++m_depth;",
			"        m_tree.reserve(2 * m_n);",
			"        m_tree.insert(m_tree.begin(), m_n, acted_monoid_type::one());",
			"        m_tree.resize(2 * m_n, acted_monoid_type::one());",
			"        m_lazy.resize(m_n, operator_monoid_type::one());",
			"        build();",
			"    }",
			"    template <typename T>",
			"    explicit LazySegmentTree(std::initializer_list<T> il) : LazySegmentTree(il.begin(), il.end()) {}",
			"",
			"    // 要素数を取得する．",
			"    int size() const { return m_sz; }",
			"    // k番目の要素をaに置き換える．O(log N).",
			"    void set(int k, const acted_value_type &a) {",
			"        set(k, acted_monoid_type(a));",
			"    }",
			"    void set(int k, const acted_monoid_type &a) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        m_tree[k] = a;",
			"        for(int i = 1; i <= m_depth; ++i) update(k >> i);",
			"    }",
			"    // k番目の要素を作用素fを用いて更新する．O(log N).",
			"    void apply(int k, const operator_value_type &f) {",
			"        apply(k, operator_monoid_type(f));",
			"    }",
			"    void apply(int k, const operator_monoid_type &f) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        m_tree[k] = f.act(m_tree[k]);",
			"        for(int i = 1; i <= m_depth; ++i) update(k >> i);",
			"    }",
			"    // 区間[l,r)の要素を作用素fを用いて更新する．O(log N).",
			"    void apply(int l, int r, const operator_value_type &f) {",
			"        apply(l, r, operator_monoid_type(f));",
			"    }",
			"    void apply(int l, int r, const operator_monoid_type &f) {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        if(l == r) return;",
			"        l += m_n, r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            if((l >> i) << i != l) push(l >> i);",
			"            if((r >> i) << i != r) push((r - 1) >> i);",
			"        }",
			"        for(int ll = l, rr = r; ll < rr; ll >>= 1, rr >>= 1) {",
			"            if(ll & 1) apply_with_lazy(ll++, f);",
			"            if(rr & 1) apply_with_lazy(--rr, f);",
			"        }",
			"        for(int i = 1; i <= m_depth; ++i) {",
			"            if((l >> i) << i != l) update(l >> i);",
			"            if((r >> i) << i != r) update((r - 1) >> i);",
			"        }",
			"    }",
			"    // k番目の要素を求める．O(log N).",
			"    acted_value_type prod(int k) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        return m_tree[k].value();",
			"    }",
			"    // 区間[l,r)の要素の総積を求める．O(log N).",
			"    acted_value_type prod(int l, int r) {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        if(l == r) return acted_monoid_type::one().value();",
			"        l += m_n, r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            if((l >> i) << i != l) push(l >> i);",
			"            if((r >> i) << i != r) push((r - 1) >> i);",
			"        }",
			"        acted_monoid_type &&val_l = acted_monoid_type::one(), &&val_r = acted_monoid_type::one();",
			"        for(; l < r; l >>= 1, r >>= 1) {",
			"            if(l & 1) val_l = val_l * m_tree[l++];",
			"            if(r & 1) val_r = m_tree[--r] * val_r;",
			"        }",
			"        return (val_l * val_r).value();",
			"    }",
			"    // 区間全体の要素の総積を取得する．O(1).",
			"    acted_value_type prod_all() const { return m_tree[1].value(); }",
			"    // pred(prod(l,r))==true となる区間の最右位値rを二分探索する．",
			"    // ただし，区間[l,n)の要素はpred(S)によって区分化されていること．また，pred(e)==true であること．O(log N).",
			"    template <bool (*pred)(acted_value_type)>",
			"    int most_right(int l) const {",
			"        return most_right(l, [](const acted_value_type &x) -> bool { return pred(x); });",
			"    }",
			"    template <class Pred>",
			"    int most_right(int l, Pred pred) const {",
			"        static_assert(std::is_invocable_r<bool, Pred, acted_value_type>::value);",
			"        assert(0 <= l and l <= size());",
			"        assert(pred(acted_monoid_type::one().value()));",
			"        if(l == m_sz) return m_sz;",
			"        l += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(l >> i);",
			"        acted_monoid_type &&val = acted_monoid_type::one();",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            acted_monoid_type &&tmp = val * m_tree[l];",
			"            if(!pred(tmp.value())) {",
			"                while(l < m_n) {",
			"                    push(l);",
			"                    l <<= 1;",
			"                    tmp = val * m_tree[l];",
			"                    if(pred(tmp.value())) val = tmp, ++l;",
			"                }",
			"                return l - m_n;",
			"            }",
			"            val = tmp, ++l;",
			"        } while((l & -l) != l);",
			"        return m_sz;",
			"    }",
			"    // pred(prod(l,r))==true となる区間の最左位値lを二分探索する．",
			"    // ただし，区間[0,r)の要素はpred(S)によって区分化されていること．また，pred(e)==true であること．O(log N).",
			"    template <bool (*pred)(acted_value_type)>",
			"    int most_left(int r) const {",
			"        return most_left(r, [](const acted_value_type &x) -> bool { return pred(x); });",
			"    }",
			"    template <class Pred>",
			"    int most_left(int r, Pred pred) const {",
			"        static_assert(std::is_invocable_r<bool, Pred, acted_value_type>::value);",
			"        assert(0 <= r and r <= size());",
			"        assert(pred(acted_monoid_type::one().value()));",
			"        if(r == 0) return 0;",
			"        r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push((r - 1) >> i);",
			"        acted_monoid_type &&val = acted_monoid_type::one();",
			"        do {",
			"            --r;",
			"            while(r > 1 and (r & 1)) r >>= 1;",
			"            acted_monoid_type &&tmp = m_tree[r] * val;",
			"            if(!pred(tmp.value())) {",
			"                while(r < m_n) {",
			"                    push(r);",
			"                    r = r << 1 | 1;",
			"                    tmp = m_tree[r] * val;",
			"                    if(pred(tmp.value())) val = tmp, --r;",
			"                }",
			"                return r - m_n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);",
			"        return 0;",
			"    }",
			"    void reset() {",
			"        std::fill(m_tree.begin() + 1, m_tree.end(), acted_monoid_type::one());",
			"        std::fill(m_lazy.begin() + 1, m_lazy.end(), operator_monoid_type::one());",
			"    }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const LazySegmentTree &rhs) {",
			"        os << \"{\\n  [\\n\";",
			"        for(int i = 0; i <= rhs.m_depth; ++i) {",
			"            int l = 1 << i, r = 2 << i;",
			"            for(int j = l; j < r; ++j) os << (j == l ? \"    [\" : \" \") << rhs.m_tree[j].value();",
			"            os << \"]\\n\";",
			"        }",
			"        os << \"  ],\\n  [\\n\";",
			"        for(int i = 0; i < rhs.m_depth; ++i) {",
			"            int l = 1 << i, r = 2 << i;",
			"            for(int j = l; j < r; ++j) os << (j == l ? \"    [\" : \" \") << rhs.m_lazy[j].value();",
			"            os << \"]\\n\";",
			"        }",
			"        return os << \"  ]\\n}\";",
			"    }",
			"};",
			"",
			"namespace internal {",
			"",
			"namespace range_sum_range_update {",
			"",
			"template <typename T>",
			"struct S {",
			"    T val;",
			"    int size;",
			"",
			"    constexpr S() : S(T(), 0) {}",
			"    constexpr S(const T &val) : S(val, 1) {}",
			"    constexpr S(const T &val, int size) : val(val), size(size) {}",
			"",
			"    friend constexpr S operator+(const S &lhs, const S &rhs) { return {lhs.val + rhs.val, lhs.size + rhs.size}; }",
			"    friend std::ostream &operator<<(std::ostream &os, const S &rhs) { return os << \"{\" << rhs.val << \", \" << rhs.size << \"}\"; }",
			"};",
			"",
			"template <typename T>",
			"using acted_monoid = algebra::Monoid<S<T>, algebra::boperator::plus<S<T>>, algebra::element::zero<S<T>>>;",
			"",
			"template <typename F>",
			"constexpr auto id = algebra::element::max<F>;",
			"",
			"template <typename F>",
			"constexpr auto compose = algebra::boperator::assign_if_not_id<F, id<F>>;",
			"",
			"template <typename F, typename T = F>",
			"constexpr auto mapping = [](const F &f, const S<T> &x) -> S<T> {",
			"    static_assert(std::is_invocable_r<F, decltype(id<F>)>::value);",
			"    return {(f == id<F>() ? x.val : f * x.size), x.size};",
			"};",
			"",
			"template <typename F, typename T = F>",
			"using operator_monoid = algebra::OperatorMonoid<F, compose<F>, id<F>, S<T>, mapping<F, T>>;",
			"",
			"}  // namespace range_sum_range_update",
			"",
			"namespace range_sum_range_add {",
			"",
			"template <typename T>",
			"using S = range_sum_range_update::S<T>;",
			"",
			"template <typename T>",
			"using acted_monoid = range_sum_range_update::acted_monoid<T>;",
			"",
			"template <typename F>",
			"constexpr auto id = algebra::element::zero<F>;",
			"",
			"template <typename F>",
			"constexpr auto compose = algebra::boperator::plus<F>;",
			"",
			"template <typename F, typename T = F>",
			"constexpr auto mapping = [](const F &f, const S<T> &x) -> S<T> { return {x.val + f * x.size, x.size}; };",
			"",
			"template <typename F, typename T = F>",
			"using operator_monoid = algebra::OperatorMonoid<F, compose<F>, id<F>, S<T>, mapping<F, T>>;",
			"",
			"}  // namespace range_sum_range_add",
			"",
			"namespace range_sum_range_affine {",
			"",
			"template <typename T>",
			"using S = range_sum_range_update::S<T>;",
			"",
			"template <typename T>",
			"using acted_monoid = range_sum_range_update::acted_monoid<T>;",
			"",
			"template <typename U>",
			"struct F {",
			"    U a;",
			"    U b;",
			"",
			"    constexpr F() : F(U(), U()) {}",
			"    constexpr F(const U &a, const U &b) : a(a), b(b) {}",
			"",
			"    friend constexpr F operator*(const F &lhs, const F &rhs) { return {lhs.a * rhs.a, lhs.a * rhs.b + lhs.b}; }",
			"    friend std::ostream &operator<<(std::ostream &os, const F &rhs) { return os << \"{\" << rhs.a << \", \" << rhs.b << \"}\"; }",
			"};",
			"",
			"template <typename U>",
			"constexpr auto id = []() -> F<U> { return {1, 0}; };",
			"",
			"template <typename U>",
			"constexpr auto compose = algebra::boperator::mul<F<U>>;",
			"",
			"template <typename U, typename T = U>",
			"constexpr auto mapping = [](const F<U> &f, const S<T> &x) -> S<T> { return {f.a * x.val + f.b * x.size, x.size}; };",
			"",
			"template <typename U, typename T = U>",
			"using operator_monoid = algebra::OperatorMonoid<F<U>, compose<U>, id<U>, S<T>, mapping<U, T>>;",
			"",
			"}  // namespace range_sum_range_affine",
			"",
			"}  // namespace internal",
			"",
			"template <typename S, typename F = S>",
			"using range_minimum_range_update_lazy_segment_tree = LazySegmentTree<algebra::monoid::minimum_safe<S>, algebra::operator_monoid::assign_for_minimum<F, S>>;",
			"",
			"template <typename S, typename F = S>",
			"using range_minimum_range_add_lazy_segment_tree = LazySegmentTree<algebra::monoid::minimum<S>, algebra::operator_monoid::addition<F, S>>;",
			"",
			"template <typename S, typename F = S>",
			"using range_maximum_range_update_lazy_segment_tree = LazySegmentTree<algebra::monoid::maximum_safe<S>, algebra::operator_monoid::assign_for_maximum<F, S>>;",
			"",
			"template <typename S, typename F = S>",
			"using range_maximum_range_add_lazy_segment_tree = LazySegmentTree<algebra::monoid::maximum<S>, algebra::operator_monoid::addition<F, S>>;",
			"",
			"template <typename T, typename F = T>",
			"using range_sum_range_update_lazy_segment_tree = LazySegmentTree<internal::range_sum_range_update::acted_monoid<T>, internal::range_sum_range_update::operator_monoid<F, T>>;",
			"",
			"template <typename T, typename F = T>",
			"using range_sum_range_add_lazy_segment_tree = LazySegmentTree<internal::range_sum_range_add::acted_monoid<T>, internal::range_sum_range_add::operator_monoid<F, T>>;",
			"",
			"template <typename T, typename U = T>",
			"using range_sum_range_affine_lazy_segment_tree = LazySegmentTree<internal::range_sum_range_affine::acted_monoid<T>, internal::range_sum_range_affine::operator_monoid<U, T>>;",
			"",
			"}  // namespace lazy_segment_tree"
		],
		"description": ""
	}
}