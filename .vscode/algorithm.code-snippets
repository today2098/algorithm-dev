{
	// Place your algorithm-dev ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"BIT": {
		"scope": "cpp",
		"prefix": "BIT",
		"body": [
			"// Binary Indexed Tree.",
			"template <typename T>",
			"class BIT {",
			"    int m_sz;               // m_sz:=(配列の要素数).",
			"    std::vector<T> m_tree;  // 1-based index.",
			"",
			"    void build() {",
			"        for(int i = 1; i < size(); ++i) {",
			"            int j = i + (i & -i);",
			"            if(j <= size()) m_tree[j] += m_tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT() : BIT(0) {};",
			"    explicit BIT(size_t n, T a = 0) : m_sz(n), m_tree(n + 1, a) {",
			"        if(a != 0) build();",
			"    }",
			"    explicit BIT(const std::vector<T> &v) : m_sz(v.size()), m_tree(v.size() + 1) {",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + 1);",
			"        build();",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // k番目の要素にaを加算する．O(logN).",
			"    void add(int k, T a) {",
			"        assert(1 <= k and k <= size());",
			"        for(; k <= size(); k += k & -k) m_tree[k] += a;",
			"    }",
			"    // 区間[1,r]の要素の総和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= size());",
			"        T res = 0;",
			"        for(; r > 0; r -= r & -r) res += m_tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r]の要素の総和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(1 <= l and l <= r and r <= size());",
			"        return sum(r) - sum(l - 1);",
			"    }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(m_tree.begin() + 1, m_tree.end(), a);",
			"        if(a != 0) build();",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree"
	},
	"BIT0": {
		"scope": "cpp",
		"prefix": "BIT0",
		"body": [
			"// Binary Indexed Tree (0-based index).",
			"template <typename T>",
			"class BIT0 {",
			"    int m_sz;               // m_sz:=(配列の要素数).",
			"    std::vector<T> m_tree;  // 0-based index.",
			"",
			"    void build() {",
			"        for(int i = 0; i < size() - 1; ++i) {",
			"            int j = i | (i + 1);",
			"            if(j < size()) m_tree[j] += m_tree[i];",
			"        }",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    BIT0() : BIT0(0) {};",
			"    explicit BIT0(size_t n, T a = 0) : m_sz(n), m_tree(n, a) {",
			"        if(a != 0) build();",
			"    }",
			"    explicit BIT0(const std::vector<T> &v) : m_sz(v.size()), m_tree(v) {",
			"        build();",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // k番目の要素にaを加算する．O(logN).",
			"    void add(int k, T a) {",
			"        assert(0 <= k and k < size());",
			"        for(; k < size(); k |= k + 1) m_tree[k] += a;",
			"    }",
			"    // 区間[0,r)の要素の総和を求める．O(logN).",
			"    T sum(int r) const {",
			"        assert(0 <= r and r <= size());",
			"        T res = 0;",
			"        for(r = r - 1; r >= 0; r = (r & (r + 1)) - 1) res += m_tree[r];",
			"        return res;",
			"    }",
			"    // 区間[l,r)の要素の総和を求める．O(logN).",
			"    T sum(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        return sum(r) - sum(l);",
			"    }",
			"    // 全要素をaで埋める．O(N).",
			"    void fill(T a = 0) {",
			"        std::fill(m_tree.begin(), m_tree.end(), a);",
			"        if(a != 0) build();",
			"    }",
			"};"
		],
		"description": "Binary Indexed Tree (0-based index)"
	},
	"BellmanFord": {
		"scope": "cpp",
		"prefix": "BellmanFord",
		"body": [
			"template <typename T>",
			"class BellmanFord {",
			"    struct Edge {",
			"        int from, to;",
			"        T cost;",
			"        explicit Edge(int from_, int to_, T cost_) : from(from_), to(to_), cost(cost_) {}",
			"    };",
			"",
			"    int m_vn;                   // m_vn:=(ノード数).",
			"    std::vector<Edge> m_edges;  // m_edges[]:=(辺リスト).",
			"    std::vector<T> m_d;         // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;     // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"",
			"public:",
			"    BellmanFord() : BellmanFord(0) {}",
			"    explicit BellmanFord(size_t vn) : m_vn(vn), m_d(vn, infinity()), m_pre(vn, -1) {}",
			"    explicit BellmanFord(size_t vn, size_t en) : BellmanFord(vn) {",
			"        m_edges.reserve(en);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 辺数を返す．",
			"    int size() const { return m_edges.size(); }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_edges.emplace_back(from, to, cost);",
			"    }",
			"    // グラフ全体から負閉路を検出する．O(|V|*|E|).",
			"    bool find_negative_cycle() const {",
			"        std::vector<T> nd(order(), 0);",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(nd[to] > nd[from] + cost) {",
			"                    nd[to] = nd[from] + cost;",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) return false;  // 負閉路なし．",
			"        }",
			"        return true;  // 負閉路あり．",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|V|*|E|).",
			"    bool bellman_ford(int s) {",
			"        assert(0 <= s and s < order());",
			"        std::fill(m_d.begin(), m_d.end(), infinity());",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        m_d[s] = 0;",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(m_d[from] == infinity()) continue;",
			"                if(m_d[to] > m_d[from] + cost) {",
			"                    m_d[to] = m_d[from] + cost;",
			"                    m_pre[to] = from;",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) return false;  // 負閉路なし．",
			"        }",
			"        for(int i = 0; i < order(); ++i) {",
			"            bool update = false;",
			"            for(const auto &[from, to, cost] : m_edges) {",
			"                if(m_d[from] == infinity() or m_d[to] == -infinity()) continue;",
			"                if(m_d[from] == -infinity() or m_d[to] > m_d[from] + cost) {",
			"                    m_d[to] = -infinity();",
			"                    update = true;",
			"                }",
			"            }",
			"            if(!update) break;",
			"        }",
			"        return true;  // 負閉路あり．",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < order());",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> shortest_path(int t) const {",
			"        assert(0 <= t and t < order());",
			"        std::vector<int> path;",
			"        if(distance(t) == infinity() or distance(t) == -infinity()) return path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "Bellman-Ford Algorithm（単一始点最短経路）"
	},
	"Combination": {
		"scope": "cpp",
		"prefix": "Combination",
		"body": [
			"// 組合せ（mod付き）．",
			"template <int mod>",
			"class Combination {",
			"    int m_mx;                       // m_mx:=(引数nの最大値).",
			"    std::vector<long long> m_fact;  // m_fact[n]:=(nの階乗).",
			"    std::vector<long long> m_inv;   // m_inv[n]:=(nの逆元).",
			"    std::vector<long long> m_finv;  // m_finv[n]:=(nの階乗の逆元).",
			"",
			"public:",
			"    // constructor. 制約は，modが素数かつ mx<mod であること．O(N).",
			"    Combination() : Combination(51e4) {}",
			"    explicit Combination(int mx) : m_mx(mx), m_fact(mx + 1), m_inv(mx + 1), m_finv(mx + 1) {",
			"        static_assert(mod >= 1);",
			"        assert(1 <= m_mx and m_mx < mod);",
			"        m_fact[0] = m_fact[1] = 1;",
			"        m_inv[1] = 1;",
			"        m_finv[0] = m_finv[1] = 1;",
			"        for(int n = 2; n <= m_mx; ++n) {",
			"            m_fact[n] = m_fact[n - 1] * n % mod;",
			"            m_inv[n] = mod - m_inv[mod % n] * (mod / n) % mod;",
			"            m_finv[n] = m_finv[n - 1] * m_inv[n] % mod;",
			"        }",
			"    }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    // 階乗．O(1).",
			"    long long factorial(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_fact[n];",
			"    }",
			"    // 逆元．O(1).",
			"    long long inverse(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        return m_inv[n];",
			"    }",
			"    // 階乗の逆元．O(1).",
			"    long long inverse_fact(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_finv[n];",
			"    }",
			"    // 順列．O(1).",
			"    long long nPk(int n, int k) const {",
			"        assert(0 <= k and k <= n and n <= m_mx);",
			"        return m_fact[n] * m_finv[n - k] % mod;",
			"    }",
			"    // 組合せ．O(1).",
			"    long long nCk(int n, int k) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        assert(k >= 0);",
			"        if(k > n) return 0;",
			"        return m_fact[n] * m_finv[n - k] % mod * m_finv[k] % mod;",
			"    }",
			"    // 重複組合せ．O(1).",
			"    long long nHk(int n, int k) const {",
			"        assert(n >= 1 and k >= 0);",
			"        return nCk(k + n - 1, k);",
			"    }",
			"};",
			"",
			"using Combination998244353 = Combination<998'244'353>;",
			"using Combination1000000007 = Combination<1'000'000'007>;"
		],
		"description": "組合せ（mod付き）"
	},
	"Dijkstra": {
		"scope": "cpp",
		"prefix": "Dijkstra",
		"body": [
			"template <typename T>",
			"class Dijkstra {",
			"    int m_vn;                                           // m_vn:=(ノード数).",
			"    std::vector<std::vector<std::pair<int, T> > > m_g;  // m_g[v][]:=(ノードvの隣接リスト). pair of (to, cost).",
			"    std::vector<T> m_d;                                 // m_d[t]:=(ノードsからtへの最短距離).",
			"    std::vector<int> m_pre;                             // m_pre[t]:=(ノードtを訪問する直前のノード番号). 逆方向経路．",
			"",
			"public:",
			"    Dijkstra() : Dijkstra(0) {}",
			"    explicit Dijkstra(size_t vn) : m_vn(vn), m_g(vn), m_d(vn, infinity()), m_pre(vn, -1) {}",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_vn; }",
			"    // 重み付き有向辺を張る．",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        m_g[from].emplace_back(to, cost);",
			"    }",
			"    // ノードsから各ノードへの最短距離を求める．O(|E|*log|V|).",
			"    void dijkstra(int s) {",
			"        assert(0 <= s and s < order());",
			"        std::fill(m_d.begin(), m_d.end(), infinity());",
			"        std::fill(m_pre.begin(), m_pre.end(), -1);",
			"        std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int> >, std::greater<std::pair<T, int> > > pque;",
			"        m_d[s] = 0;",
			"        pque.emplace(m_d[s], s);",
			"        while(!pque.empty()) {",
			"            const auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(m_d[v] < dist) continue;",
			"            for(const auto &[to, cost] : m_g[v]) {",
			"                if(m_d[to] > m_d[v] + cost) {",
			"                    m_d[to] = m_d[v] + cost;",
			"                    m_pre[to] = v;",
			"                    pque.emplace(m_d[to], to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    // ノードsからtへの最短距離を返す．",
			"    T distance(int t) const {",
			"        assert(0 <= t and t < order());",
			"        return m_d[t];",
			"    }",
			"    // ノードsからtへの最短経路を復元する．",
			"    std::vector<int> shortest_path(int t) const {",
			"        assert(0 <= t and t < order());",
			"        std::vector<int> path;",
			"        if(distance(t) == infinity()) return path;",
			"        for(; t != -1; t = m_pre[t]) path.push_back(t);",
			"        std::reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};"
		],
		"description": "Dijkstra's Algorithm（単一始点最短経路）"
	},
	"Dinic": {
		"scope": "cpp",
		"prefix": "Dinic",
		"body": [
			"template <typename T>  // T:容量の型.",
			"class Dinic {",
			"    struct Edge {",
			"        int to;   // to:=(行き先ノード).",
			"        T cap;    // cap:=(容量).",
			"        int rev;  // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[i]:=(i番目の辺情報). pair of (from, index).",
			"",
			"    T dfs(int v, int t, T flow, const std::vector<int> &d, std::vector<int> &iter) {",
			"        if(v == t) return flow;",
			"        for(int &i = iter[v], n = m_g[v].size(); i < n; ++i) {",
			"            Edge &e = m_g[v][i];",
			"            if(e.cap > 0 and d[e.to] > d[v]) {",
			"                T &&res = dfs(e.to, t, std::min(flow, e.cap), d, iter);",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    m_g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    Dinic() : Dinic(0) {}",
			"    explicit Dinic(size_t vn) : m_g(vn) {}",
			"    explicit Dinic(size_t vn, size_t en) : Dinic(vn) {",
			"        m_pos.reserve(en);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す.",
			"    int size() const { return m_pos.size(); }",
			"    // 容量capの有向辺を追加する．",
			"    int add_edge(int from, int to, T cap) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, idx_to);",
			"        m_g[to].emplace_back(from, 0, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ノードsからtへの最大流を求める．O((|V|^2)*|E|).",
			"    T max_flow(int s, int t) { return max_flow(s, t, infinity()); }",
			"    T max_flow(int s, int t, T flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        T res = 0;",
			"        std::vector<int> d(order());     // d[v]:=(ノードs-v間の増加パスの長さ).",
			"        std::vector<int> iter(order());  // iter[v]:=(m_g[v][]の次に調べるべきイテレータ).",
			"        while(res < flow) {",
			"            // (1) BFS: ノードsと各ノード間の増加パスの長さを求める．",
			"            std::fill(d.begin(), d.end(), -1);",
			"            d[s] = 0;",
			"            std::queue<int> que;",
			"            que.push(s);",
			"            while(!que.empty()) {",
			"                int v = que.front();",
			"                que.pop();",
			"                for(const Edge &e : m_g[v]) {",
			"                    if(e.cap > 0 and d[e.to] == -1) {",
			"                        d[e.to] = d[v] + 1;",
			"                        que.push(e.to);",
			"                    }",
			"                }",
			"            }",
			"            if(d[t] == -1) break;",
			"            // (2) DFS: 増加パスを探す．",
			"            std::fill(iter.begin(), iter.end(), 0);",
			"            while(res < flow) {",
			"                T &&tmp = dfs(s, t, flow - res, d, iter);",
			"                if(tmp == 0) break;",
			"                res += tmp;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    // i番目の辺情報を返す．",
			"    std::tuple<int, int, T, T> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, flow).",
			"    }",
			"    // 最小カットにより，グラフ上のノードを分割する．",
			"    std::vector<bool> min_cut(int s) const {",
			"        assert(0 <= s and s < order());",
			"        std::vector<bool> res(order(), false);",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            if(res[v]) continue;",
			"            res[v] = true;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(e.cap > 0 and !res[e.to]) que.push(e.to);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "Dinic's Algorithm（最大流問題）"
	},
	"DynamicModint": {
		"scope": "cpp",
		"prefix": "DynamicModint",
		"body": [
			"class ModintBase {};",
			"",
			"template <class T>",
			"using is_modint = std::is_base_of<ModintBase, T>;",
			"",
			"template <class T>",
			"inline constexpr bool is_modint_v = is_modint<T>::value;",
			"",
			"template <int id>",
			"class DynamicModint : ModintBase {",
			"    static int mod;",
			"    long long val;",
			"",
			"    void normalize() {",
			"        if(val < -mod or mod <= val) val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"public:",
			"    DynamicModint() : DynamicModint(0) {}",
			"    DynamicModint(long long val_) : val(val_) {",
			"        assert(mod >= 1);",
			"        normalize();",
			"    }",
			"",
			"    DynamicModint operator+() const { return DynamicModint(*this); }",
			"    DynamicModint operator-() const { return (val == 0 ? DynamicModint(*this) : DynamicModint(mod - val)); }",
			"    DynamicModint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    DynamicModint operator++(int) {",
			"        DynamicModint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    DynamicModint operator--(int) {",
			"        DynamicModint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    DynamicModint &operator+=(const DynamicModint &rhs) {",
			"        val += rhs.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator-=(const DynamicModint &rhs) {",
			"        val -= rhs.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator*=(const DynamicModint &rhs) {",
			"        val = val * rhs.val % mod;",
			"        return *this;",
			"    }",
			"    DynamicModint &operator/=(const DynamicModint &rhs) { return *this *= rhs.inv(); }",
			"",
			"    friend bool operator==(const DynamicModint &lhs, const DynamicModint &rhs) { return lhs.val == rhs.val; }",
			"    friend bool operator!=(const DynamicModint &lhs, const DynamicModint &rhs) { return lhs.val != rhs.val; }",
			"    friend DynamicModint operator+(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) += rhs; }",
			"    friend DynamicModint operator-(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) -= rhs; }",
			"    friend DynamicModint operator*(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) *= rhs; }",
			"    friend DynamicModint operator/(const DynamicModint &lhs, const DynamicModint &rhs) { return DynamicModint(lhs) /= rhs; }",
			"    friend std::istream &operator>>(std::istream &is, DynamicModint &rhs) {",
			"        is >> rhs.val;",
			"        rhs.normalize();",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const DynamicModint &rhs) { return os << rhs.val; }",
			"",
			"    static constexpr int get_id() { return id; }",
			"    static void set_modulus(int mod_) {",
			"        assert(mod_ >= 1);",
			"        mod = mod_;",
			"    }",
			"    static int modulus() { return mod; }",
			"    long long value() const { return val; }",
			"    DynamicModint inv() const {",
			"        long long a = mod, b = val, u = 0, v = 1;",
			"        while(b != 0) {",
			"            long long t = a / b;",
			"            a -= b * t, u -= v * t;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return DynamicModint(u);",
			"    }",
			"    DynamicModint pow(long long k) const {",
			"        if(k < 0) return inv().pow(-k);",
			"        DynamicModint res = 1, mul = *this;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= mul;",
			"            mul *= mul;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend DynamicModint mod_inv(const DynamicModint &a) { return a.inv(); }",
			"    friend DynamicModint mod_pow(const DynamicModint &a, long long k) { return a.pow(k); }",
			"};",
			"",
			"template <int id>",
			"int DynamicModint<id>::mod = 1'000'000'007;"
		],
		"description": "動的Modint構造体"
	},
	"FordFulkerson": {
		"scope": "cpp",
		"prefix": "FordFulkerson",
		"body": [
			"template <typename T>  // T:容量の型.",
			"class FordFulkerson {",
			"    struct Edge {",
			"        int to;   // to:=(行き先ノード).",
			"        T cap;    // cap:=(容量).",
			"        int rev;  // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[]:=(i番目の辺情報). pair of (from, index).",
			"",
			"    T dfs(int v, int t, T flow, std::vector<bool> &seen) {",
			"        if(v == t) return flow;",
			"        seen[v] = true;",
			"        for(Edge &e : m_g[v]) {",
			"            if(e.cap > 0 and !seen[e.to]) {",
			"                T &&res = dfs(e.to, t, std::min(flow, e.cap), seen);",
			"                if(res > 0) {",
			"                    e.cap -= res;",
			"                    m_g[e.to][e.rev].cap += res;",
			"                    return res;",
			"                }",
			"            }",
			"        }",
			"        return 0;",
			"    }",
			"",
			"public:",
			"    FordFulkerson() : FordFulkerson(0) {}",
			"    explicit FordFulkerson(size_t vn) : m_g(vn) {}",
			"    explicit FordFulkerson(size_t vn, size_t en) : FordFulkerson(vn) {",
			"        m_pos.reserve(en);",
			"    }",
			"",
			"    static constexpr T infinity() { return std::numeric_limits<T>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す．",
			"    int size() const { return m_pos.size(); }",
			"    // 容量capの有向辺を追加する．",
			"    int add_edge(int from, int to, T cap) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, idx_to);",
			"        m_g[to].emplace_back(from, 0, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ノードsからtへの最大流を求める．O(F*|E|).",
			"    T max_flow(int s, int t) { return max_flow(s, t, infinity()); }",
			"    T max_flow(int s, int t, T flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        T res = 0;",
			"        std::vector<bool> seen(order());  // seen[v]:=(DFSにおいてノードvを調べたか).",
			"        while(res < flow) {",
			"            std::fill(seen.begin(), seen.end(), false);",
			"            T &&tmp = dfs(s, t, flow - res, seen);  // 増加パスを探す．",
			"            if(tmp == 0) break;",
			"            res += tmp;",
			"        }",
			"        return res;",
			"    }",
			"    // i番目の辺情報を返す．",
			"    std::tuple<int, int, T, T> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, flow).",
			"    }",
			"    // 最小カットにより，グラフ上のノードを分割する．",
			"    std::vector<bool> min_cut(int s) const {",
			"        assert(0 <= s and s < order());",
			"        std::vector<bool> res(order(), false);",
			"        std::queue<int> que;",
			"        que.push(s);",
			"        while(!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            if(res[v]) continue;",
			"            res[v] = true;",
			"            for(const Edge &e : m_g[v]) {",
			"                if(e.cap > 0 and !res[e.to]) que.push(e.to);",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "Ford-Fulkerson Algorithm（最大流問題）"
	},
	"LazySegTree": {
		"scope": "cpp",
		"prefix": "LazySegTree",
		"body": [
			"// Lazy Segment Tree（遅延評価セグメント木）.",
			"template <class S, class F>  // S:モノイドの型, F:写像の型.",
			"class LazySegTree {",
			"    using Op = std::function<S(const S &, const S &)>;",
			"    using Mapping = std::function<S(const F &, const S &)>;",
			"    using Composition = std::function<F(const F &, const F &)>;",
			"",
			"    Op m_op;                    // S m_op(S,S):=(二項演算関数). S×S→S.",
			"    Mapping m_mapping;          // S m_mapping(F f,S x):=(写像). f(x).",
			"    Composition m_composition;  // F m_composition(F f,F g):=(写像の合成). f∘g.",
			"    S m_e;                      // m_e:=(単位元).",
			"    F m_id;                     // m_id:=(恒等写像).",
			"    int m_sz;                   // m_sz:=(要素数).",
			"    int m_n;                    // m_n:=(完全二分木の葉数).",
			"    int m_depth;                // m_depth:=(完全二分木の深さ).",
			"    std::vector<S> m_tree;      // m_tree(2n)[]:=(完全二分木). 1-based index.",
			"    std::vector<F> m_lazy;      // m_lazy(n)[k]:=(m_tree[k]の子 (m_tree[2k], m_tree[2k+1]) に対する遅延評価).",
			"",
			"    void apply0(int k, const F &f) {",
			"        assert(1 <= k and k < 2 * m_n);",
			"        m_tree[k] = m_mapping(f, m_tree[k]);",
			"        if(k < m_n) m_lazy[k] = m_composition(f, m_lazy[k]);",
			"    }",
			"    void push(int k) {",
			"        assert(1 <= k and k < m_n);",
			"        apply0(k << 1, m_lazy[k]);",
			"        apply0(k << 1 | 1, m_lazy[k]);",
			"        m_lazy[k] = identity_mapping();",
			"    }",
			"    void update(int k) {",
			"        assert(1 <= k and k < m_n);",
			"        m_tree[k] = m_op(m_tree[k << 1], m_tree[k << 1 | 1]);",
			"    }",
			"",
			"public:",
			"    // constructor. O(N).",
			"    LazySegTree() {}",
			"    explicit LazySegTree(const Op &op, const Mapping &mapping, const Composition &composition, const S &e, const F &id, size_t n)",
			"        : m_op(op), m_mapping(mapping), m_composition(composition), m_e(e), m_id(id), m_sz(n), m_n(1), m_depth(0) {",
			"        while(m_n < size()) m_n <<= 1, m_depth++;",
			"        m_tree.assign(2 * m_n, identity());",
			"        m_lazy.assign(m_n, identity_mapping());",
			"    }",
			"    explicit LazySegTree(const Op &op, const Mapping &mapping, const Composition &composition, const S &e, const F &id, const std::vector<S> &v)",
			"        : LazySegTree(op, mapping, composition, e, id, v.size()) {",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + m_n);",
			"        for(int i = m_n - 1; i >= 1; --i) update(i);",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // モノイドの単位元を返す．",
			"    S identity() const { return m_e; }",
			"    // 恒等写像を返す．",
			"    F identity_mapping() const { return m_id; }",
			"    // k番目の要素をaに置き換える．O(logN).",
			"    void set(int k, const S &a) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        m_tree[k] = a;",
			"        for(int i = 1; i <= m_depth; ++i) update(k >> i);",
			"    }",
			"    // 区間[l,-)の要素をv[]に置き換える．O(N).",
			"    void set(int l, const std::vector<S> &v) {",
			"        assert(0 <= l and l + (int)v.size() <= size());",
			"        if(v.size() == 0) return;",
			"        l += m_n;",
			"        int r = l + (int)v.size();",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            for(int j = l >> i, end = (r - 1) >> i; j <= end; ++j) push(j);",
			"        }",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + l);",
			"        for(int i = 1; i <= m_depth; ++i) {",
			"            for(int j = l >> i, end = (r - 1) >> i; j <= end; ++j) update(j);",
			"        }",
			"    }",
			"    // k番目の要素を写像fを用いて更新する．O(logN).",
			"    void apply(int k, const F &f) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        m_tree[k] = m_mapping(f, m_tree[k]);",
			"        for(int i = 1; i <= m_depth; ++i) update(k >> i);",
			"    }",
			"    // 区間[l,r)の要素を写像fを用いて更新する．O(logN).",
			"    void apply(int l, int r, const F &f) {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        if(l == r) return;",
			"        l += m_n, r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            if((l >> i) << i != l) push(l >> i);",
			"            if((r >> i) << i != r) push((r - 1) >> i);",
			"        }",
			"        for(int l2 = l, r2 = r; l2 < r2; l2 >>= 1, r2 >>= 1) {",
			"            if(l2 & 1) apply0(l2++, f);",
			"            if(r2 & 1) apply0(--r2, f);",
			"        }",
			"        for(int i = 1; i <= m_depth; ++i) {",
			"            if((l >> i) << i != l) update(l >> i);",
			"            if((r >> i) << i != r) update((r - 1) >> i);",
			"        }",
			"    }",
			"    // k番目の要素を求める．O(logN).",
			"    S prod(int k) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(k >> i);",
			"        return m_tree[k];",
			"    }",
			"    // 区間[l,r)の要素の総積 v[l]•v[l+1]•....•v[r-1] を求める．O(logN).",
			"    S prod(int l, int r) {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        if(l == r) return identity();",
			"        l += m_n, r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) {",
			"            if((l >> i) << i != l) push(l >> i);",
			"            if((r >> i) << i != r) push((r - 1) >> i);",
			"        }",
			"        S val_l = identity(), val_r = identity();",
			"        for(; l < r; l >>= 1, r >>= 1) {",
			"            if(l & 1) val_l = m_op(val_l, m_tree[l++]);",
			"            if(r & 1) val_r = m_op(m_tree[--r], val_r);",
			"        }",
			"        return m_op(val_l, val_r);",
			"    }",
			"    // 区間全体の要素の総積を返す．O(1).",
			"    S prod_all() const { return m_tree[1]; }",
			"    // jud(prod(l,-))==true となる区間の最右位値を二分探索する．",
			"    // ただし，要素列には単調性があり，また jud(e)==true であること．O(logN).",
			"    template <class Func = std::function<bool(const S &)> >",
			"    int most_right(const Func &jud, int l) const {",
			"        assert(jud(identity()) == true);",
			"        assert(0 <= l and l <= size());",
			"        if(l == size()) return size();",
			"        l += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push(l >> i);",
			"        S val = identity();",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            S &&tmp = m_op(val, m_tree[l]);",
			"            if(!jud(tmp)) {",
			"                while(l < m_n) {",
			"                    push(l);",
			"                    l <<= 1;",
			"                    S &&tmp2 = m_op(val, m_tree[l]);",
			"                    if(jud(tmp2)) val = tmp2, l++;",
			"                }",
			"                return l - m_n;",
			"            }",
			"            val = tmp, l++;",
			"        } while((l & -l) != l);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return size();",
			"    }",
			"    // jud(prod(-,r))==true となる区間の最左位値を二分探索する．",
			"    // ただし，要素列には単調性があり，また jud(e)==true であること．O(logN).",
			"    template <class Func = std::function<bool(const S &)> >",
			"    int most_left(const Func &jud, int r) const {",
			"        assert(jud(identity()) == true);",
			"        assert(0 <= r and r <= size());",
			"        if(r == 0) return 0;",
			"        r += m_n;",
			"        for(int i = m_depth; i >= 1; --i) push((r - 1) >> i);",
			"        S val = identity();",
			"        do {",
			"            r--;",
			"            while(r > 1 and r & 1) r >>= 1;",
			"            S &&tmp = m_op(m_tree[r], val);",
			"            if(!jud(tmp)) {",
			"                while(r < m_n) {",
			"                    push(r);",
			"                    r = r << 1 | 1;",
			"                    S &&tmp2 = m_op(m_tree[r], val);",
			"                    if(jud(tmp2)) val = tmp2, r--;",
			"                }",
			"                return r - m_n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return 0;",
			"    }",
			"    void reset() {",
			"        std::fill(m_tree.begin(), m_tree.end(), identity());",
			"        std::fill(m_lazy.begin(), m_lazy.end(), identity_mapping());",
			"    }",
			"};"
		],
		"description": "Lazy Segment Tree（遅延評価セグメント木）"
	},
	"LinearSieve": {
		"scope": "cpp",
		"prefix": "LinearSieve",
		"body": [
			"// 線形篩．",
			"class LinearSieve {",
			"    int m_mx;  // m_mx:=(篩にかける最大の自然数).",
			"    // m_lpf[n]:=(自然数nの最小素因数). Least prime factor. m_lpf[n]==n のとき，nは素数．",
			"    std::vector<int> m_lpf;",
			"    std::vector<int> m_primes;  // m_primes[]:=(自然数n以下の素数リスト).",
			"",
			"public:",
			"    // constructor. n以下の自然数を篩にかける．O(N).",
			"    LinearSieve() : LinearSieve(51e4) {}",
			"    explicit LinearSieve(int n) : m_mx(n), m_lpf(n + 1, -1) {",
			"        assert(n >= 0);",
			"        for(int p = 2; p <= m_mx; ++p) {",
			"            if(m_lpf[p] == -1) {",
			"                m_lpf[p] = p;",
			"                m_primes.push_back(p);",
			"            }",
			"            for(int prime : m_primes) {",
			"                if(prime > m_lpf[p] or (long long) prime * p > m_mx) break;",
			"                m_lpf[prime * p] = prime;",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n] == n;",
			"    }",
			"    // 自然数nの最小素因数を返す．O(1).",
			"    int lpf(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::map<int, int> res;",
			"        while(n > 1) {",
			"            res[m_lpf[n]]++;",
			"            n /= m_lpf[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<int> divisors(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::vector<int> res({1});",
			"        const std::map<int, int> &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            int b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[j] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"    // 素数リストを参照する．O(1).",
			"    const std::vector<int> &primes() const { return m_primes; }",
			"};"
		],
		"description": "線形篩"
	},
	"Modint": {
		"scope": "cpp",
		"prefix": "Modint",
		"body": [
			"class ModintBase {};",
			"",
			"template <class T>",
			"using is_modint = std::is_base_of<ModintBase, T>;",
			"",
			"template <class T>",
			"inline constexpr bool is_modint_v = is_modint<T>::value;",
			"",
			"template <int mod>",
			"class Modint : ModintBase {",
			"    long long val;",
			"",
			"    constexpr void normalize() {",
			"        if(val < -mod or mod <= val) val %= mod;",
			"        if(val < 0) val += mod;",
			"    }",
			"",
			"public:",
			"    constexpr Modint() : Modint(0) {}",
			"    constexpr Modint(long long val_) : val(val_) {",
			"        static_assert(mod >= 1);",
			"        normalize();",
			"    }",
			"",
			"    constexpr Modint operator+() const { return Modint(*this); }",
			"    constexpr Modint operator-() const { return (val == 0 ? Modint(*this) : Modint(mod - val)); }",
			"    constexpr Modint &operator++() {",
			"        val++;",
			"        if(val == mod) val = 0;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator--() {",
			"        if(val == 0) val = mod;",
			"        val--;",
			"        return *this;",
			"    }",
			"    constexpr Modint operator++(int) {",
			"        Modint res = *this;",
			"        ++(*this);",
			"        return res;",
			"    }",
			"    constexpr Modint operator--(int) {",
			"        Modint res = *this;",
			"        --(*this);",
			"        return res;",
			"    }",
			"    constexpr Modint &operator+=(const Modint &rhs) {",
			"        val += rhs.val;",
			"        if(val >= mod) val -= mod;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator-=(const Modint &rhs) {",
			"        val -= rhs.val;",
			"        if(val < 0) val += mod;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator*=(const Modint &rhs) {",
			"        val = val * rhs.val % mod;",
			"        return *this;",
			"    }",
			"    constexpr Modint &operator/=(const Modint &rhs) { return *this *= rhs.inv(); }",
			"",
			"    friend constexpr bool operator==(const Modint &lhs, const Modint &rhs) { return lhs.val == rhs.val; }",
			"    friend constexpr bool operator!=(const Modint &lhs, const Modint &rhs) { return lhs.val != rhs.val; }",
			"    friend constexpr Modint operator+(const Modint &lhs, const Modint &rhs) { return Modint(lhs) += rhs; }",
			"    friend constexpr Modint operator-(const Modint &lhs, const Modint &rhs) { return Modint(lhs) -= rhs; }",
			"    friend constexpr Modint operator*(const Modint &lhs, const Modint &rhs) { return Modint(lhs) *= rhs; }",
			"    friend constexpr Modint operator/(const Modint &lhs, const Modint &rhs) { return Modint(lhs) /= rhs; }",
			"    friend std::istream &operator>>(std::istream &is, Modint &rhs) {",
			"        is >> rhs.val;",
			"        rhs.normalize();",
			"        return is;",
			"    }",
			"    friend std::ostream &operator<<(std::ostream &os, const Modint &rhs) { return os << rhs.val; }",
			"",
			"    static constexpr int modulus() { return mod; }",
			"    constexpr long long value() const { return val; }",
			"    constexpr Modint inv() const {",
			"        long long a = mod, b = val, u = 0, v = 1;",
			"        while(b != 0) {",
			"            long long t = a / b;",
			"            a -= b * t, u -= v * t;",
			"            std::swap(a, b), std::swap(u, v);",
			"        }",
			"        return Modint(u);",
			"    }",
			"    constexpr Modint pow(long long k) const {",
			"        if(k < 0) return inv().pow(-k);",
			"        Modint res = 1, mul = *this;",
			"        while(k > 0) {",
			"            if(k & 1LL) res *= mul;",
			"            mul *= mul;",
			"            k >>= 1;",
			"        }",
			"        return res;",
			"    }",
			"",
			"    friend constexpr Modint mod_inv(const Modint &a) { return a.inv(); }",
			"    friend constexpr Modint mod_pow(const Modint &a, long long k) { return a.pow(k); }",
			"};",
			"",
			"using mint998244353 = Modint<998'244'353>;",
			"using mint1000000007 = Modint<1'000'000'007>;"
		],
		"description": "Modint構造体"
	},
	"PascalTriangle": {
		"scope": "cpp",
		"prefix": "PascalTriangle",
		"body": [
			"template <typename Type = long long>",
			"class PascalTriangle {",
			"public:",
			"    int m_mx;                             // m_mx:=(引数nの最大値).",
			"    std::vector<std::vector<Type> > m_c;  // m_c[n][k]:=(C(n,k) and C(n,n-k)).",
			"",
			"public:",
			"    // constructor. O(N^2).",
			"    PascalTriangle() : PascalTriangle(51e2) {}",
			"    explicit PascalTriangle(int mx) : m_mx(mx), m_c(mx + 1) {",
			"        assert(mx >= 0);",
			"        for(int n = 0; n <= m_mx; ++n) {",
			"            const int len = (n + 2) / 2;",
			"            m_c[n].resize(len);",
			"            m_c[n][0] = 1;",
			"            for(int k = 1; k < len; ++k) m_c[n][k] = nCk(n - 1, k - 1) + nCk(n - 1, k);",
			"        }",
			"    }",
			"",
			"    // 組合せ．O(1).",
			"    Type nCk(int n, int k) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        assert(k >= 0);",
			"        if(k > n) return 0;",
			"        return (k <= n - k ? m_c[n][k] : m_c[n][n - k]);",
			"    }",
			"    // 重複組合せ．O(1).",
			"    Type nHk(int n, int k) const {",
			"        assert(n >= 1 and k >= 0);",
			"        return nCk(k + n - 1, k);",
			"    }",
			"};"
		],
		"description": "Pascal's Triangle（パスカルの三角形）"
	},
	"PrimalDual": {
		"scope": "cpp",
		"prefix": "PrimalDual",
		"body": [
			"template <typename Flow, typename Cost>  // Flow:容量の型, Cost:コストの型.",
			"class PrimalDual {",
			"    struct Edge {",
			"        int to;     // to:=(行き先ノード).",
			"        Flow cap;   // cap:=(容量).",
			"        Cost cost;  // cost:=(単位コスト).",
			"        int rev;    // rev:=(逆辺イテレータ).",
			"        explicit Edge(int to_, Flow cap_, Cost cost_, int rev_) : to(to_), cap(cap_), cost(cost_), rev(rev_) {}",
			"    };",
			"",
			"    std::vector<std::vector<Edge> > m_g;      // m_g[v][]:=(ノードvの隣接リスト).",
			"    std::vector<std::pair<int, int> > m_pos;  // m_pos[i]:=(i番目の辺情報). pair of (from, index).",
			"",
			"    static constexpr Cost infinity_cost() { return std::numeric_limits<Cost>::max(); }",
			"    void dijkstra(int s, const std::vector<Cost> &h, std::vector<Cost> &d, std::vector<int> &prev_v, std::vector<int> &prev_e,",
			"                  std::priority_queue<std::pair<Cost, int>, std::vector<std::pair<Cost, int> >, std::greater<std::pair<Cost, int> > > &pque) {",
			"        std::fill(d.begin(), d.end(), infinity_cost());",
			"        d[s] = 0;",
			"        pque.emplace(0, s);",
			"        while(!pque.empty()) {",
			"            auto [dist, v] = pque.top();",
			"            pque.pop();",
			"            if(d[v] < dist) continue;",
			"            for(int i = 0, n = m_g[v].size(); i < n; ++i) {",
			"                const Edge &e = m_g[v][i];",
			"                Cost new_cost = e.cost + h[v] - h[e.to];",
			"                if(e.cap > 0 and d[e.to] > d[v] + new_cost) {",
			"                    d[e.to] = d[v] + new_cost;",
			"                    prev_v[e.to] = v;",
			"                    prev_e[e.to] = i;",
			"                    pque.emplace(d[e.to], e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"public:",
			"    PrimalDual() : PrimalDual(0) {}",
			"    explicit PrimalDual(size_t vn) : m_g(vn) {}",
			"    explicit PrimalDual(size_t vn, size_t en) : PrimalDual(vn) {",
			"        m_pos.reserve(en);",
			"    }",
			"",
			"    static constexpr Flow infinity_flow() { return std::numeric_limits<Flow>::max(); }",
			"    // ノード数を返す．",
			"    int order() const { return m_g.size(); }",
			"    // 辺数を返す.",
			"    int size() const { return m_pos.size(); }",
			"    // 容量cap[flows]，単位コストcost[cost/flow]の有向辺を追加する．",
			"    int add_edge(int from, int to, Flow cap, Cost cost) {",
			"        assert(0 <= from and from < order());",
			"        assert(0 <= to and to < order());",
			"        assert(cap >= 0);",
			"        assert(cost >= 0);",
			"        int idx_from = m_g[from].size(), idx_to = m_g[to].size();",
			"        if(from == to) idx_to++;",
			"        m_g[from].emplace_back(to, cap, cost, idx_to);",
			"        m_g[to].emplace_back(from, 0, -cost, idx_from);",
			"        m_pos.emplace_back(from, idx_from);",
			"        return size() - 1;",
			"    }",
			"    // ソースからシンクまでの最小費用[costs]（単位コスト[cost/flow]とフロー[flows]の積の総和）を求める．",
			"    // 返り値は流量[flows]と最小費用[costs]．O(F*|E|*log|V|).",
			"    std::pair<Flow, Cost> min_cost_flow(int s, int t) { return slope(s, t, infinity_flow()).back(); }",
			"    std::pair<Flow, Cost> min_cost_flow(int s, int t, Flow flow) { return slope(s, t, flow).back(); }",
			"    std::vector<std::pair<Flow, Cost> > slope(int s, int t) { return slope(s, t, infinity_flow()); }",
			"    std::vector<std::pair<Flow, Cost> > slope(int s, int t, Flow flow) {",
			"        assert(0 <= s and s < order());",
			"        assert(0 <= t and t < order());",
			"        Flow rest = flow;                                   // rest:=(残流量).",
			"        Cost sum = 0;                                       // sum:=(合計費用).",
			"        Cost prev_cost = -1;                                // prev_cost:=(直前のフローにおける単位コスト[cost/flow]).",
			"        std::vector<std::pair<Flow, Cost> > res({{0, 0}});  // res[]:=(流量とコストの関係の折れ線). 値は狭義単調増加．",
			"        std::vector<Cost> d(order());                       // d[v]:=(ノートsからvまでの最小単位コスト).",
			"        std::vector<Cost> h(order(), 0);                    // h[v]:=(ノードvのポテンシャル).",
			"        std::vector<int> prev_v(order());                   // prev_v[v]:=(ノードvの直前に訪れるノード). 逆方向経路．",
			"        std::vector<int> prev_e(order());                   // prev_e[v]:=(ノードvの直前に通る辺). 逆方向経路．",
			"        std::priority_queue<std::pair<Cost, int>, std::vector<std::pair<Cost, int> >, std::greater<std::pair<Cost, int> > > pque;",
			"        while(rest > 0) {",
			"            dijkstra(s, h, d, prev_v, prev_e, pque);",
			"            if(d[t] == infinity_cost()) break;  // これ以上流せない場合．",
			"            for(int v = 0, n = order(); v < n; ++v) h[v] += d[v];",
			"            Flow tmp = rest;",
			"            for(int v = t; v != s; v = prev_v[v]) tmp = std::min(tmp, m_g[prev_v[v]][prev_e[v]].cap);",
			"            rest -= tmp;",
			"            sum += h[t] * tmp;",
			"            if(h[t] == prev_cost) res.pop_back();",
			"            res.emplace_back(flow - rest, sum);",
			"            for(int v = t; v != s; v = prev_v[v]) {",
			"                Edge &e = m_g[prev_v[v]][prev_e[v]];",
			"                e.cap -= tmp;",
			"                m_g[v][e.rev].cap += tmp;",
			"            }",
			"            prev_cost = h[t];",
			"        }",
			"        return res;",
			"    }",
			"    // i番目の辺情報を返す．",
			"    std::tuple<int, int, Flow, Cost, Flow> get_edge(int i) const {",
			"        assert(0 <= i and i < size());",
			"        const auto &[from, idx] = m_pos[i];",
			"        const Edge &e = m_g[from][idx];",
			"        return {from, e.to, e.cap + m_g[e.to][e.rev].cap, e.cost, m_g[e.to][e.rev].cap};  // tuple of (from, to, cap, cost, flow).",
			"    }",
			"    void reset() {",
			"        for(const auto &[from, idx] : m_pos) {",
			"            Edge &e = m_g[from][idx];",
			"            e.cap = e.cap + m_g[e.to][e.rev].cap;",
			"            m_g[e.to][e.rev].cap = 0;",
			"        }",
			"    }",
			"};"
		],
		"description": "最小費用流問題"
	},
	"SegmentSieve": {
		"scope": "cpp",
		"prefix": "SegmentSieve",
		"body": [
			"// 区間篩．",
			"class SegmentSieve {",
			"    long long m_l, m_r;",
			"    long long m_sr;                                  // m_sr:=√r.",
			"    std::vector<long long> m_small;                  // m_small[n]:=(区間[2,√r)の自然数nにおける最小素因数).",
			"    std::vector<std::map<long long, int> > m_large;  // m_large[n-l][]:=(区間[l,r)の自然数nにおける区間[2,√r)のいくつかの素因数).",
			"    std::vector<long long> m_aux;                    // m_aux[n-l]:=(m_large[n-l][]の積).",
			"",
			"public:",
			"    // constructor. 区間[l,r)の自然数を篩にかける．制約の目安はおおよそ 2<=l<r<=1e12, r-l<=1e6．",
			"    SegmentSieve() : SegmentSieve(2, 3) {}",
			"    explicit SegmentSieve(long long l, long long r) : m_l(l), m_r(r), m_large(r - l), m_aux(r - l, 1) {",
			"        assert(2 <= l and l < r);",
			"        m_sr = std::sqrt(m_r) + 1;",
			"        m_small.assign(m_sr, -1);",
			"        std::iota(m_small.begin() + 2, m_small.end(), 2);",
			"        for(long long p = 2; p * p < m_r; ++p) {",
			"            if(m_small[p] == p) {",
			"                for(long long q = p * p; q < m_sr; q += p) m_small[q] = p;",
			"                for(long long q = (m_l + p - 1) / p * p; q < m_r; q += p) {",
			"                    long long tmp = q;",
			"                    while(m_aux[q - m_l] * m_aux[q - m_l] < m_r and tmp % p == 0) {",
			"                        m_large[q - m_l][p]++;",
			"                        m_aux[q - m_l] *= p;",
			"                        tmp /= p;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        return m_large[n - m_l].size() == 0;",
			"    }",
			"    // 高速素因数分解．",
			"    std::map<long long, int> prime_factorize(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        std::map<long long, int> res = m_large[n - m_l];",
			"        n /= m_aux[n - m_l];",
			"        if(n >= m_sr) {",
			"            res[n]++;",
			"            return res;",
			"        }",
			"        while(n > 1) {",
			"            res[m_small[n]]++;",
			"            n /= m_small[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<long long> divisors(long long n) const {",
			"        assert(m_l <= n and n < m_r);",
			"        std::vector<long long> res({1});",
			"        const std::map<long long, int> &&pf = prime_factorize(n);",
			"        int capacity = 1;",
			"        for(const auto &[_, cnt] : pf) capacity *= (cnt + 1);",
			"        res.reserve(capacity);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            long long b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[j] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"};"
		],
		"description": "区間篩"
	},
	"SegmentTree": {
		"scope": "cpp",
		"prefix": "SegmentTree",
		"body": [
			"template <typename S>",
			"class SegmentTree {",
			"    using Op = std::function<S(const S &, const S &)>;",
			"",
			"    Op m_op;                // S m_op(S,S):=(二項演算関数).",
			"    S m_e;                  // m_e:=(単位元).",
			"    int m_sz;               // m_sz:=(要素数).",
			"    int m_n;                // m_n:=(完全二分木の葉数).",
			"    std::vector<S> m_tree;  // m_tree(2n)[]:=(完全二分木). 1-based index.",
			"",
			"public:",
			"    // constructor. O(N).",
			"    SegmentTree() {};",
			"    explicit SegmentTree(const Op &op, const S &e, size_t n) : m_op(op), m_e(e), m_sz(n), m_n(1) {",
			"        while(m_n < size()) m_n <<= 1;",
			"        m_tree.assign(2 * m_n, identity());",
			"    }",
			"    explicit SegmentTree(const Op &op, const S &e, const std::vector<S> &v) : SegmentTree(op, e, v.size()) {",
			"        std::copy(v.begin(), v.end(), m_tree.begin() + m_n);",
			"        for(int i = m_n - 1; i >= 1; --i) m_tree[i] = m_op(m_tree[i << 1], m_tree[i << 1 | 1]);",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // 単位元を返す．",
			"    S identity() const { return m_e; }",
			"    // k番目の要素をaに置き換える．O(logN).",
			"    void set(int k, const S &a) {",
			"        assert(0 <= k and k < size());",
			"        k += m_n;",
			"        m_tree[k] = a;",
			"        while(k >>= 1) m_tree[k] = m_op(m_tree[k << 1], m_tree[k << 1 | 1]);",
			"    }",
			"    // k番目の要素を返す．O(1).",
			"    S prod(int k) const {",
			"        assert(0 <= k and k < size());",
			"        return m_tree[k + m_n];",
			"    }",
			"    // 区間[l,r)の要素の総積 v[l]•v[l+1]•...•v[r-1] を求める．O(logN).",
			"    S prod(int l, int r) const {",
			"        assert(0 <= l and l <= r and r <= size());",
			"        S val_l = identity(), val_r = identity();",
			"        l += m_n, r += m_n;",
			"        while(l < r) {",
			"            if(l & 1) val_l = m_op(val_l, m_tree[l++]);",
			"            if(r & 1) val_r = m_op(m_tree[--r], val_r);",
			"            l >>= 1, r >>= 1;",
			"        }",
			"        return m_op(val_l, val_r);",
			"    }",
			"    // 区間全体の要素の総積を返す．O(1).",
			"    S prod_all() const { return m_tree[1]; }",
			"    // f(prod(l,-))==true となる区間の最右位値を二分探索する．",
			"    // ただし，要素列には単調性があり，また f(e)==true であること．O(logN).",
			"    template <class Func = std::function<bool(const S &)> >",
			"    int most_right(const Func &f, int l) const {",
			"        assert(f(identity()) == true);",
			"        assert(0 <= l and l <= size());",
			"        if(l == size()) return size();",
			"        S val = identity();",
			"        l += m_n;",
			"        do {",
			"            while(!(l & 1)) l >>= 1;",
			"            S &&tmp = m_op(val, m_tree[l]);",
			"            if(!f(tmp)) {",
			"                while(l < m_n) {",
			"                    l <<= 1;",
			"                    S &&tmp2 = m_op(val, m_tree[l]);",
			"                    if(f(tmp2)) val = tmp2, l++;",
			"                }",
			"                return l - m_n;",
			"            }",
			"            val = tmp, l++;",
			"        } while((l & -l) != l);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return size();",
			"    }",
			"    // f(prod(-,r))==true となる区間の最左位値を二分探索する．",
			"    // ただし，要素列には単調性があり，また f(e)==true であること．O(logN).",
			"    template <class Func = std::function<bool(const S &)> >",
			"    int most_left(const Func &f, int r) const {",
			"        assert(f(identity()) == true);",
			"        assert(0 <= r and r <= size());",
			"        if(r == 0) return 0;",
			"        S val = identity();",
			"        r += m_n;",
			"        do {",
			"            r--;",
			"            while(r > 1 and r & 1) r >>= 1;",
			"            S &&tmp = m_op(m_tree[r], val);",
			"            if(!f(tmp)) {",
			"                while(r < m_n) {",
			"                    r = (r << 1) | 1;",
			"                    S &&tmp2 = m_op(m_tree[r], val);",
			"                    if(f(tmp2)) val = tmp2, r--;",
			"                }",
			"                return r - m_n + 1;",
			"            }",
			"            val = tmp;",
			"        } while((r & -r) != r);  // (x&-x)==x のとき，xは2の階乗数．",
			"        return 0;",
			"    }",
			"    void reset() { std::fill(m_tree.begin(), m_tree.end(), identity()); }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const SegmentTree &segtree) {",
			"        int l = 1, r = 2;",
			"        os << \"[\\n\";",
			"        while(l < 2 * segtree.m_n) {",
			"            os << \"  [\";",
			"            for(int i = l; i < r; ++i) os << (i == l ? \"\" : \" \") << segtree.m_tree[i];",
			"            os << \"]\\n\";",
			"            l <<= 1, r <<= 1;",
			"        }",
			"        os << \"]\";",
			"        return os;",
			"    }",
			"};"
		],
		"description": ""
	},
	"Sieve": {
		"scope": "cpp",
		"prefix": "Sieve",
		"body": [
			"// Sieve of Eratosthenes（エラトステネスの篩）.",
			"class Sieve {",
			"    int m_mx;  // m_mx:=(篩にかける最大の自然数).",
			"    // m_lpf[n]:=(自然数nの最小素因数). Least prime factor. m_lpf[n]==n のとき，nは素数．",
			"    std::vector<int> m_lpf;",
			"",
			"public:",
			"    // constructor. n以下の自然数を篩にかける．O(N*loglogN).",
			"    Sieve() : Sieve(51e4) {}",
			"    explicit Sieve(int n) : m_mx(n), m_lpf(n + 1, -1) {",
			"        assert(n >= 0);",
			"        std::iota(m_lpf.begin() + 2, m_lpf.end(), 2);",
			"        for(int p = 2; p * p <= m_mx; ++p) {",
			"            if(m_lpf[p] == p) {",
			"                for(int q = p * p; q <= m_mx; q += p) {",
			"                    if(m_lpf[q] == q) m_lpf[q] = p;",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    // 素数判定．O(1).",
			"    bool is_prime(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n] == n;",
			"    }",
			"    // 自然数nの最小素因数を返す．O(1).",
			"    int lpf(int n) const {",
			"        assert(0 <= n and n <= m_mx);",
			"        return m_lpf[n];",
			"    }",
			"    // 高速素因数分解．O(logN).",
			"    std::map<int, int> prime_factorize(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::map<int, int> res;",
			"        while(n > 1) {",
			"            res[m_lpf[n]]++;",
			"            n /= m_lpf[n];",
			"        }",
			"        return res;",
			"    }",
			"    // 高速約数列挙．",
			"    std::vector<int> divisors(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        std::vector<int> res({1});",
			"        const std::map<int, int> &&pf = prime_factorize(n);",
			"        for(const auto &[p, cnt] : pf) {",
			"            const int sz = res.size();",
			"            int b = 1;",
			"            for(int i = 0; i < cnt; ++i) {",
			"                b *= p;",
			"                for(int j = 0; j < sz; ++j) res.push_back(res[j] * b);",
			"            }",
			"        }",
			"        std::sort(res.begin(), res.end());",
			"        return res;",
			"    }",
			"    // オイラーのファイ関数．n以下でnと互いに素な自然数の個数を求める．",
			"    int totient(int n) const {",
			"        assert(1 <= n and n <= m_mx);",
			"        const std::map<int, int> &&pf = prime_factorize(n);",
			"        int res = n;",
			"        for(const auto &[p, _] : pf) res -= res / p;",
			"        return res;",
			"    }",
			"    // メビウス関数．O(N*loglogN).",
			"    std::vector<int> mobius() const {",
			"        std::vector<int> res(m_mx + 1, 1);  // res[n]:=μ(n).",
			"        for(int p = 2; p <= m_mx; ++p) {",
			"            if(m_lpf[p] == p) {",
			"                res[p] = -1;",
			"                for(int q = 2 * p; q <= m_mx; q += p) {",
			"                    if((q / p) % p == 0) res[q] = 0;  // nがある素数pで2回以上割り切れるとき，μ(n)=0.",
			"                    else res[q] = -res[q];            // nがk個の相異なる素因数で分解できるとき，μ(n)=(-1)^k.",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Sieve of Eratosthenes（エラトステネスの篩）"
	},
	"SparseTable": {
		"scope": "cpp",
		"prefix": "SparseTable",
		"body": [
			"// 静的な数列に対し，結合則 (A•B)•C=A•(B•C) と冪等性 A•A=A が成り立つ演算（min/max, gcd/lcm, bitwise-and/orなど）の区間クエリを求める．",
			"template <typename S>  // S:冪等半群の型.",
			"class SparseTable {",
			"    using Op = std::function<S(const S &, const S &)>;",
			"",
			"    Op m_op;                               // S m_op(S,S):=(二項演算関数).",
			"    int m_sz;                              // m_sz:=(要素数).",
			"    std::vector<int> m_lb;                 // m_lb[x]:=floor(log2(x)).",
			"    std::vector<std::vector<S> > m_table;  // m_table[k][i]:=(区間[i,i+2^k)の総積).",
			"",
			"public:",
			"    using value_type = S;",
			"",
			"    // constructor. O(N*logN).",
			"    SparseTable() {}",
			"    explicit SparseTable(const Op &op, const std::vector<S> &v) : m_op(op), m_sz(v.size()), m_lb(v.size() + 1, 0) {",
			"        for(int i = 2; i <= size(); ++i) m_lb[i] = m_lb[i >> 1] + 1;",
			"        m_table.resize(m_lb[size()] + 1);",
			"        m_table[0].assign(v.begin(), v.end());",
			"        for(int k = 1; k <= m_lb[size()]; ++k) {",
			"            int n = size() - (1 << k) + 1;",
			"            m_table[k].resize(n);",
			"            for(int i = 0; i < n; ++i) m_table[k][i] = m_op(m_table[k - 1][i], m_table[k - 1][i + (1 << (k - 1))]);",
			"        }",
			"    }",
			"",
			"    // 要素数を返す．",
			"    int size() const { return m_sz; }",
			"    // 区間[l,r)の総積を求める．O(1).",
			"    S fold(int l, int r) const {",
			"        assert(0 <= l and l < r and r <= size());",
			"        int k = m_lb[r - l];",
			"        return m_op(m_table[k][l], m_table[k][r - (1 << k)]);",
			"    }",
			"};"
		],
		"description": "Sparse Table"
	},
	"UnionFind": {
		"scope": "cpp",
		"prefix": "UnionFind",
		"body": [
			"class UnionFind {",
			"    int m_vn;  // m_vn:=(要素数).",
			"    int m_gn;  // m_gn:=(グループ数).",
			"    // m_par[x]:=(要素xの親番号). 0未満の場合，xは根であり，値の絶対値は属するグループのサイズを表す．",
			"    std::vector<int> m_par;",
			"",
			"public:",
			"    UnionFind() : UnionFind(0) {}",
			"    explicit UnionFind(size_t vn) : m_vn(vn), m_gn(vn), m_par(vn, -1) {}",
			"",
			"    // 要素の総数を返す．",
			"    int vn() const { return m_vn; };",
			"    // グループ数を返す．",
			"    int gn() const { return m_gn; };",
			"    // 要素xが属するグループ（根付き木）の根番号を返す．O(α(N)).",
			"    int root(int x) {",
			"        assert(0 <= x and x < vn());",
			"        if(m_par[x] < 0) return x;",
			"        return m_par[x] = root(m_par[x]);  // 経路圧縮．",
			"    }",
			"    // 要素xが属するグループのサイズを返す．",
			"    int size(int x) {",
			"        assert(0 <= x and x < vn());",
			"        return -m_par[root(x)];",
			"    }",
			"    // 要素x, yが同じグループに属するか判定する．",
			"    bool is_same(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        return root(x) == root(y);",
			"    }",
			"    // 要素xが属するグループと要素yが属するグループとを併合する．",
			"    bool unite(int x, int y) {",
			"        assert(0 <= x and x < vn());",
			"        assert(0 <= y and y < vn());",
			"        x = root(x), y = root(y);",
			"        if(x == y) return false;                // Do nothing.",
			"        if(size(x) < size(y)) std::swap(x, y);  // Merge technique (union by size).",
			"        m_par[x] += m_par[y];",
			"        m_par[y] = x;",
			"        m_gn--;",
			"        return true;",
			"    }",
			"    void reset() {",
			"        m_gn = vn();",
			"        std::fill(m_par.begin(), m_par.end(), -1);",
			"    }",
			"};"
		],
		"description": "Union-Find（素集合データ構造）"
	},
	"compress": {
		"scope": "cpp",
		"prefix": "compress",
		"body": [
			"// 座標圧縮．O(N*logN).",
			"template <typename Type>",
			"std::vector<Type> compress(std::vector<Type> &v) {",
			"    std::vector<Type> key = v;",
			"    std::sort(key.begin(), key.end());",
			"    key.erase(std::unique(key.begin(), key.end()), key.end());",
			"    for(auto &elem : v) elem = std::lower_bound(key.begin(), key.end(), elem) - key.begin();",
			"    return key;",
			"}"
		],
		"description": "座標圧縮"
	},
	"divisors": {
		"scope": "cpp",
		"prefix": "divisors",
		"body": [
			"// 約数列挙．O(√N).",
			"template <typename Type>",
			"std::vector<Type> divisors(Type n) {",
			"    assert(n >= 1);",
			"    std::vector<Type> res;  // res[]:=(自然数nの約数の集合).",
			"    for(Type p = 1; p * p <= n; ++p) {",
			"        if(n % p == 0) {",
			"            res.push_back(p);",
			"            Type q = n / p;",
			"            if(q != p) res.push_back(q);",
			"        }",
			"    }",
			"    std::sort(res.begin(), res.end());",
			"    return res;",
			"}"
		],
		"description": "約数列挙"
	},
	"edit_distance": {
		"scope": "cpp",
		"prefix": "edit_distance",
		"body": [
			"// 2つの配列に対して，編集距離 (Edit Distance) を求める．",
			"// 引数はSTLのシーケンスコンテナであること．O(|S|*|T|).",
			"template <class Sequence>",
			"int edit_distance(const Sequence &s, const Sequence &t) {",
			"    const int n = s.size(), m = t.size();",
			"    // dp[i][j]:=(s[:i]とt[:j]の編集距離).",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));",
			"    for(int i = 1; i <= n; ++i) dp[i][0] = i;",
			"    for(int j = 1; j <= m; ++j) dp[0][j] = j;",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < m; ++j) {",
			"            dp[i + 1][j + 1] = std::min({dp[i][j + 1] + 1,",
			"                                         dp[i + 1][j] + 1,",
			"                                         dp[i][j] + (s[i] == t[j] ? 0 : 1)});",
			"        }",
			"    }",
			"    return dp[n][m];",
			"}"
		],
		"description": "Edit Distance（編集距離）"
	},
	"extgcd": {
		"scope": "cpp",
		"prefix": "extgcd",
		"body": [
			"// 拡張ユークリッドの互除法．",
			"// ax+by=gcd(a,b) を満たす整数の組(x,y)を求め，gcd(a,b)を返す．O(log(min(a,b))).",
			"template <typename Type>",
			"Type extgcd(Type a, Type b, Type &x, Type &y) {",
			"    if(b == 0) {",
			"        x = 1, y = 0;",
			"        return a;",
			"    }",
			"    Type &&d = extgcd(b, a % b, y, x);",
			"    y -= a / b * x;",
			"    return d;",
			"}"
		],
		"description": "拡張ユークリッドの互除法"
	},
	"is_prime": {
		"scope": "cpp",
		"prefix": "is_prime",
		"body": [
			"// 素数判定．O(√N).",
			"template <typename Type>",
			"constexpr bool is_prime(Type n) {",
			"    assert(n >= 0);",
			"    if(n < 2) return false;",
			"    if(n == 2) return true;",
			"    if(n % 2 == 0) return false;",
			"    for(Type p = 3; p * p <= n; p += 2) {",
			"        if(n % p == 0) return false;",
			"    }",
			"    return true;",
			"}"
		],
		"description": "素数判定"
	},
	"largest_rectangle": {
		"scope": "cpp",
		"prefix": "largest_rectangle",
		"body": [
			"// 最大長方形問題．",
			"// 各iにおいて，comp(H[i], H[] within [l,r))==true となるiを含む最大区間[l,r)を求める．O(N).",
			"template <typename Type, class Compare = std::function<bool(const Type &, const Type &)> >",
			"std::vector<std::pair<int, int> > largest_rectangle(",
			"    const std::vector<Type> &h,",
			"    const Compare &comp = [](const Type &a, const Type &b) -> bool { return a <= b; }) {",
			"    const int n = h.size();",
			"    std::vector<std::pair<int, int> > res(n, {0, n});  // res[i]:=(pair of [l,r)).",
			"    std::stack<std::pair<Type, int> > st;",
			"    // left side.",
			"    for(int i = 0; i < n; ++i) {",
			"        while(!st.empty() and comp(h[i], st.top().first)) st.pop();",
			"        if(!st.empty()) res[i].first = st.top().second + 1;",
			"        st.push({h[i], i});",
			"    }",
			"    // right side.",
			"    st = std::stack<std::pair<Type, int> >();",
			"    for(int i = n - 1; i >= 0; --i) {",
			"        while(!st.empty() and comp(h[i], st.top().first)) st.pop();",
			"        if(!st.empty()) res[i].second = st.top().second;",
			"        st.push({h[i], i});",
			"    }",
			"    return res;",
			"}"
		],
		"description": "最大長方形問題"
	},
	"lcs": {
		"scope": "cpp",
		"prefix": "lcs",
		"body": [
			"// 2つの配列に対して，最長共通部分列 (LCS: Longest Common Subsequence) を求める．",
			"// 引数はSTLのシーケンスコンテナであること．O(|S|*|T|).",
			"template <class Sequence>",
			"Sequence lcs(const Sequence &s, const Sequence &t) {",
			"    const int n = s.size(), m = t.size();",
			"    // dp[i][j]:=(s[:i]とt[:j]のLCSの長さ).",
			"    std::vector<std::vector<int> > dp(n + 1, std::vector<int>(m + 1, 0));",
			"    for(int i = 0; i < n; ++i) {",
			"        for(int j = 0; j < m; ++j) {",
			"            dp[i + 1][j + 1] = (s[i] == t[j] ? dp[i][j] + 1 : std::max(dp[i][j + 1], dp[i + 1][j]));",
			"        }",
			"    }",
			"    Sequence sub(dp[n][m], 0);  // sub[]:=(配列s, tのLCS).",
			"    int i = n - 1, j = m - 1, k = dp[n][m] - 1;",
			"    while(k >= 0) {",
			"        if(s[i] == t[j]) {",
			"            sub[k] = s[i];",
			"            i--, j--, k--;",
			"        } else if(dp[i + 1][j + 1] == dp[i][j + 1]) {",
			"            i--;",
			"        } else {",
			"            j--;",
			"        }",
			"    }",
			"    return sub;",
			"}"
		],
		"description": "Longest Common Subsequence（最長共通部分列）"
	},
	"lis": {
		"scope": "cpp",
		"prefix": "lis",
		"body": [
			"// 最長増加部分列 (LIS: Longest Increasing Subsequence) の長さを求める．O(N*logN).",
			"template <typename Type, class Compare = std::function<bool(const Type &, const Type &)> >",
			"std::vector<int> lis(const std::vector<Type> &v, Compare comp = [](const Type &a, const Type &b) -> bool { return a < b; }) {",
			"    const int n = v.size();",
			"    std::vector<int> res(n, 0);  // res[i]:=(v[i]を最後の要素とする最長増加部分列の長さ).",
			"    std::vector<Type> dp;        // dp[k]:=(長さkの増加部分列のうち，その最後の要素の最小値).",
			"    for(int i = 0; i < n; ++i) {",
			"        auto itr = std::lower_bound(dp.begin(), dp.end(), v[i], comp);",
			"        res[i] = itr - dp.begin() + 1;",
			"        if(itr == dp.end()) dp.push_back(v[i]);",
			"        else *itr = v[i];",
			"    }",
			"    return res;",
			"}",
			"",
			"// 最長増加部分列 (LIS: Longest Increasing Subsequence) の長さを求める．O(N*logN).",
			"template <typename Type, class Compare = std::function<bool(const Type &, const Type &)> >",
			"std::vector<int> lis2(const std::vector<Type> &v, Compare comp = [](const Type &a, const Type &b) -> bool { return a < b; }) {",
			"    const int n = v.size();",
			"    std::vector<int> res(n + 1, 0);  // res[i]:=(v[:i]における最長増加部分列の長さ).",
			"    std::vector<Type> dp;            // dp[k]:=(長さkの増加部分列のうち，その最後の要素の最小値).",
			"    for(int i = 0; i < n; ++i) {",
			"        auto itr = std::lower_bound(dp.begin(), dp.end(), v[i], comp);",
			"        if(itr == dp.end()) dp.push_back(v[i]);",
			"        else *itr = v[i];",
			"        res[i + 1] = dp.size();",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Longest Increasing Subsequence（最長増加部分列）"
	},
	"mod_inv": {
		"scope": "cpp",
		"prefix": "mod_inv",
		"body": [
			"// モジュラ逆数（乗法逆元）．",
			"// a^-1 mod m を求める．解が存在する必要十分条件は，aとmが互いに素であること．O(log a).",
			"template <typename Type>",
			"Type mod_inv(long long a, Type m) {",
			"    assert(m > 1);",
			"    long long b = m, u = 1, v = 0;",
			"    while(b != 0) {",
			"        long long t = a / b;",
			"        a -= b * t, u -= v * t;",
			"        std::swap(a, b), std::swap(u, v);",
			"    }",
			"    // assert((\"a and m need to be coprime.\", a == 1));",
			"    if(u < 0) u += m;",
			"    return u;",
			"}"
		],
		"description": "モジュラ逆数（乗法逆元）"
	},
	"mod_pow": {
		"scope": "cpp",
		"prefix": "mod_pow",
		"body": [
			"// 繰り返し二乗法（mod付き）．n^k mod m を求める．O(logK).",
			"constexpr int mod_pow(long long n, long long k, int m) {",
			"    assert(k >= 0);",
			"    assert(m >= 1);",
			"    long long res = 1;",
			"    n %= m;",
			"    while(k > 0) {",
			"        if(k & 1LL) res = res * n % m;",
			"        n = n * n % m;",
			"        k >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "繰り返し二乗法（mod付き）"
	},
	"nPk, nCk, nHk": {
		"scope": "cpp",
		"prefix": "nPk, nCk, nHk",
		"body": [
			"// 順列．O(K).",
			"constexpr long long nPk(long long n, int k) {",
			"    assert(0 <= k and k <= n);",
			"    long long res = 1;",
			"    for(int i = 0; i < k; ++i) res = res * (n - i);",
			"    return res;",
			"}",
			"",
			"// 組合せ．O(min(K,N-K)).",
			"constexpr long long nCk(long long n, int k) {",
			"    assert(n >= 0 and k >= 0);",
			"    if(k > n) return 0;",
			"    long long res = 1;",
			"    k = std::min<long long>(k, n - k);",
			"    for(int i = 0; i < k; ++i) res = res * (n - i) / (i + 1);",
			"    return res;",
			"}",
			"",
			"// 重複組合せ．O(min(N-1,K)).",
			"constexpr long long nHk(long long n, long long k) {",
			"    assert(n >= 1 and k >= 0);",
			"    return nCk(k + n - 1, k);",
			"}"
		],
		"description": "順列，組合せ，重複組合せ"
	},
	"prime_factorize": {
		"scope": "cpp",
		"prefix": "prime_factorize",
		"body": [
			"// 素因数分解．O(√N).",
			"template <typename Type>",
			"std::map<Type, int> prime_factorize(Type n) {",
			"    assert(n >= 0);",
			"    std::map<Type, int> res;  // res[p]:=(自然数nに含まれる素因数pの個数).",
			"    while(n % 2 == 0) res[2]++, n /= 2;",
			"    for(Type p = 3; p * p <= n; p += 2) {",
			"        while(n % p == 0) res[p]++, n /= p;",
			"    }",
			"    if(n > 1) res[n] = 1;",
			"    return res;",
			"}"
		],
		"description": "素因数分解"
	},
	"z_algorithm": {
		"scope": "cpp",
		"prefix": "z_algorithm",
		"body": [
			"// 最長共通接頭辞 (LCP: Longest Common Prefix) の長さを求める．",
			"// 引数はSTLのシーケンスコンテナであること．O(|S|).",
			"template <class Sequence>",
			"std::vector<int> z_algorithm(const Sequence &s) {",
			"    const int n = s.size();",
			"    std::vector<int> z(n);  // z[i]:=(sとs[i:]のLCPの長さ).",
			"    z[0] = n;",
			"    int i = 1, j = 0;",
			"    while(i < n) {",
			"        while(i + j < n and s[j] == s[i + j]) j++;",
			"        z[i] = j;",
			"        if(j == 0) {",
			"            i++;",
			"            continue;",
			"        }",
			"        int k = 1;",
			"        while(i + k < n and k + z[k] < j) {",
			"            z[i + k] = z[k];",
			"            k++;",
			"        }",
			"        i += k, j -= k;",
			"    }",
			"    return z;",
			"}"
		],
		"description": "Z algorithm（最長共通接頭辞）"
	},
	"Declaration of SegmentTree (RMQ)": {
		"scope": "cpp",
		"prefix": "segtree",
		"body": [
			"using S=${1:int};",
			"const S e=${2:2*INF};",
			"auto op=[](const S &lhs,const S &rhs)->S{return ${3:min(lhs,rhs)};};",
			"SegmentTree<S> segtree(op,e,${4:0});"
		],
		"description": ""
	},
	"Declaration of SegmentTree (RSQ)": {
		"scope": "cpp",
		"prefix": "segtree",
		"body": [
			"using S=${1:llong};",
			"const S e=${2:0};",
			"auto op=[](const S &lhs,const S &rhs)->S{return ${3:lhs+rhs};};",
			"SegmentTree<S> segtree(op,e,${4:0});"
		],
		"description": ""
	},
	"Declaration of LazySegTree (RMQ & RUQ)": {
		"scope": "cpp",
		"prefix": "lazy_segtree",
		"body": [
			"using S=int;",
			"using F=int;",
			"const S e=2*INF;",
			"const F id=2*INF+1;",
			"auto op=[&](const S &lhs,const S &rhs)->S{return min(lhs,rhs);};",
			"auto mapping=[&](const F &f,const S &x)->S{return (f==id?x:f);};",
			"auto composition=[&](const F &f,const F &g)->F{return (f==id?g:f);};",
			"LazySegTree<S,F> lazy_segtree(op,mapping,composition,e,id,${1:0});"
		],
		"description": ""
	},
	"Declaration of LazySegTree (RMQ & RAQ)": {
		"scope": "cpp",
		"prefix": "lazy_segtree",
		"body": [
			"using S=int;",
			"using F=int;",
			"const S e=2*INF;",
			"const F id=0;",
			"auto op=[&](const S &lhs,const S &rhs)->S{return min(lhs,rhs);};",
			"auto mapping=[&](const F &f,const S &x)->S{return x+f;};",
			"auto composition=[&](const F &f,const F &g)->F{return f+g;};",
			"LazySegTree<S,F> lazy_segtree(op,mapping,composition,e,id,vector<S>(${1:0},0));"
		],
		"description": ""
	},
	"Declaration of LazySegTree (RSQ & RUQ)": {
		"scope": "cpp",
		"prefix": "lazy_segtree",
		"body": [
			"using S=struct{",
			"    llong val;",
			"    int size;",
			"};",
			"using F=llong;",
			"const S e=(S){0,0};",
			"const F id=9*LINF+1;",
			"auto op=[&](const S &lhs,const S &rhs)->S{return (S){lhs.val+rhs.val,lhs.size+rhs.size};};",
			"auto mapping=[&](const F &f,const S &x)->S{return (S){(f==id?x.val:f*x.size),x.size};};",
			"auto composition=[&](const F &f,const F &g)->F{return (f==id?g:f);};",
			"LazySegTree<S,F> lazy_segtree(op,mapping,composition,e,id,vector<S>(${1:0},(S){0,1}));"
		],
		"description": ""
	},
	"Declaration of LazySegTree (RSQ & RAQ)": {
		"scope": "cpp",
		"prefix": "lazy_segtree",
		"body": [
			"using S=struct{",
			"    llong val;",
			"    int size;",
			"};",
			"using F=llong;",
			"const S e=(S){0,0};",
			"const F id=0;",
			"auto op=[&](const S &lhs,const S &rhs)->S{return (S){lhs.val+rhs.val,lhs.size+rhs.size};};",
			"auto mapping=[&](const F &f,const S &x)->S{return (S){x.val+f*x.size,x.size};};",
			"auto composition=[&](const F &f,const F &g)->F{return f+g;};",
			"LazySegTree<S,F> lazy_segtree(op,mapping,composition,e,id,vector<S>(${1:0},(S){0,1}));"
		],
		"description": ""
	},
	"Declaration of LazySegTree (Range Affine Range Sum)": {
		"scope": "cpp",
		"prefix": "lazy_segtree",
		"body": [
			"using S=struct{",
			"    llong val;",
			"    int size;",
			"};",
			"using F=struct{",
			"    llong a;",
			"    llong b;",
			"};",
			"const S e=(S){0,0};",
			"const F id=(F){1,0};",
			"auto op=[&](const S &lhs,const S &rhs)->S{return (S){lhs.val+rhs.val,lhs.size+rhs.size};};",
			"auto mapping=[&](const F &f,const S &x)->S{return (S){f.a*x.val+f.b*x.size,x.size};};",
			"auto composition=[&](const F &f,const F &g)->F{return (F){f.a*g.a,f.a*g.b+f.b};};",
			"LazySegTree<S,F> lazy_segtree(op,mapping,composition,e,id,vector<S>(${1:0},(S){0,1}));"
		],
		"description": ""
	}
}